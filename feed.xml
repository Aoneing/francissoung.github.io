<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Francis Soung</title>
    <description>这是一个程序员的日记薄，记录工作与生活的点点滴滴。包括WEB程序开发、Linux服务器管理、LAMP/LNMP环境配置优化、PHP网络技术、MySQL优化等技术分享以及个人生活旅行中的所见所闻所解。</description>
    <link>http://www.francissoung.com/</link>
    <atom:link href="http://www.francissoung.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 24 Mar 2016 23:59:06 +0800</pubDate>
    <lastBuildDate>Thu, 24 Mar 2016 23:59:06 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>App架构设计经验谈:接口的设计</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;安全机制的设计&lt;/h3&gt;

&lt;p&gt;现在，大部分App的接口都&lt;strong&gt;采用RESTful架构&lt;/strong&gt;，RESTFul最重要的一个设计原则就是，&lt;strong&gt;客户端与服务器的交互在请求之间是无状态的&lt;/strong&gt;，也就是说，当涉及到用户状态时，每次请求都要带上身份验证信息。实现上，大部分都&lt;strong&gt;采用token的认证方式&lt;/strong&gt;，一般流程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用户用密码登录成功后，服务器返回token给客户端；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;客户端将token保存在本地，发起后续的相关请求时，将token发回给服务器；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务器检查token的有效性，有效则返回数据，若无效，分两种情况：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;token错误，这时需要用户重新登录，获取正确的token&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;token过期，这时客户端需要再发起一次认证请求，获取新的token&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而，此种验证方式存在一个安全性问题：当登录接口被劫持时，黑客就获取到了用户密码和token，后续则可以对该用户做任何事情了。用户只有修改密码才能夺回控制权。&lt;/p&gt;

&lt;p&gt;如何优化呢？&lt;strong&gt;第一种解决方案是采用HTTPS&lt;/strong&gt;。HTTPS在HTTP的基础上添加了SSL安全协议，自动对数据进行了压缩加密，在一定程序可以防止监听、防止劫持、防止重发，安全性可以提高很多。不过，SSL也不是绝对安全的，也存在被劫持的可能。另外，服务器对HTTPS的配置相对有点复杂，还需要到CA申请证书，而且一般还是收费的。而且，HTTPS效率也比较低。一般，只有安全要求比较高的系统才会采用HTTPS，比如银行。而大部分对安全要求没那么高的App还是采用HTTP的方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们目前的做法是给每个接口都添加签名&lt;/strong&gt;。给客户端分配一个密钥，每次请求接口时，将密钥和所有参数组合成源串，根据签名算法生成签名值，发送请求时将签名一起发送给服务器验证。类似的实现可参考OAuth1.0的签名算法。这样，黑客不知道密钥，不知道签名算法，就算拦截到登录接口，后续请求也无法成功操作。不过，因为签名算法比较麻烦，而且容易出错，只适合对内的接口。如果你们的接口属于开放的API，则不太适合这种签名认证的方式了，建议还是使用OAuth2.0的认证机制。&lt;/p&gt;

&lt;p&gt;我们也给每个端分配一个appKey，比如Android、iOS、微信三端，每个端分别分配一个appKey和一个密钥。没有传appKey的请求将报错，传错了appKey的请求也将报错。这样，安全性方面又加多了一层防御，同时也方便对不同端做一些不同的处理策略。&lt;/p&gt;

&lt;p&gt;另外，现在越来越多App取消了密码登录，而采用手机号+短信验证码的登录方式，我在当前的项目中也采用了这种登录方式。这种登录方式有几种好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不需要注册，不需要修改密码，也不需要因为忘记密码而重置密码的操作了；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户不再需要记住密码了，也不怕密码泄露的问题了；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;相对于密码登录其安全性明显提高了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;接口数据的设计&lt;/h4&gt;

&lt;p&gt;接口的数据一般都采用JSON格式进行传输，不过，需要注意的是，JSON的值只有六种数据类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Number：整数或浮点数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;String：字符串&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Boolean：true 或 false&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Array：数组包含在方括号[]中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Object：对象包含在大括号{}中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Null：空类型&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，传输的数据类型不能超过这六种数据类型。以前，我们曾经试过传输Date类型，它会转为类似于”2016年1月7日 09时17分42秒 GMT+08:00”这样的字符串，这在转换时会产生问题，不同的解析库解析方式可能不同，有的可能会转乱，有的可能直接异常了。要避免出错，必须做特殊处理，自己手动去做解析。为了根除这种问题，最好的解决方案是用毫秒数表示日期。&lt;/p&gt;

&lt;p&gt;另外，以前的项目中还出现过字符串的”true”和”false”，或者字符串的数字，甚至还出现过字符串的”null”，导致解析错误，尤其是”null”，导致App奔溃，后来查了好久才查出来是该问题导致的。这都是因为服务端对数据没处理好，导致有些数据转为了字符串。所以，在客户端，也不能完全信任服务端传回的数据都是对的，需要对所有异常情况都做相应处理。&lt;/p&gt;

&lt;p&gt;服务器返回的数据结构，一般为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;code：0&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;message:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;key1:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;value1,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;key2:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;value2,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;code: 状态码，0表示成功，非0表示各种不同的错误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;message: 描述信息，成功时为”success”，错误时则是错误信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;data: 成功时返回的数据，类型为对象或数组&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不同错误需要定义不同的状态码，属于客户端的错误和服务端的错误也要区分，比如1XX表示客户端的错误，2XX表示服务端的错误。这里举几个例子：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0：成功&lt;/li&gt;
  &lt;li&gt;100：请求错误&lt;/li&gt;
  &lt;li&gt;101：缺少appKey&lt;/li&gt;
  &lt;li&gt;102：缺少签名&lt;/li&gt;
  &lt;li&gt;103：缺少参数&lt;/li&gt;
  &lt;li&gt;200：服务器出错&lt;/li&gt;
  &lt;li&gt;201：服务不可用&lt;/li&gt;
  &lt;li&gt;202：服务器正在重启&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;错误信息一般有两种用途：一是客户端开发人员调试时看具体是什么错误；二是作为App错误提示直接展示给用户看。主要还是作为App错误提示，直接展示给用户看的。所以，大部分都是简短的提示信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;data字段只在请求成功时才会有数据返回的&lt;/strong&gt;。数据类型限定为对象或数组，当请求需要的数据为单个对象时则传回对象，当请求需要的数据是列表时，则为某个对象的数组。这里需要注意的就是，不要将data传入字符串或数字，即使请求需要的数据只有一个，比如token，那返回的data应该为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 正确
data: { token: 123456 }

// 错误
data: 123456
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;接口版本的设计&lt;/h3&gt;

&lt;p&gt;接口不可能一成不变，在不停迭代中，总会发生变化。接口的变化一般会有几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据的变化，比如增加了旧版本不支持的数据类型&lt;/li&gt;
  &lt;li&gt;参数的变化，比如新增了参数&lt;/li&gt;
  &lt;li&gt;接口的废弃，不再使用该接口了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了适应这些变化，必须得做接口版本的设计。实现上，一般有两种做法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个接口有各自的版本，一般为接口添加个version的参数。&lt;/li&gt;
  &lt;li&gt;整个接口系统有统一的版本，一般在URL中添加版本号，比如http://api.domain.com/v2。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大部分情况下会采用第一种方式，当某一个接口有变动时，在这个接口上叠加版本号，并兼容旧版本。App的新版本开发传参时则将传入新版本的version。&lt;/p&gt;

&lt;p&gt;如果整个接口系统的根基都发生变动的话，比如微博API，从OAuth1.0升级到OAuth2.0，整个API都进行了升级。&lt;/p&gt;

&lt;p&gt;有时候，一个接口的变动还会影响到其他接口，但做的时候不一定能发现。因此，最好还要有一套完善的测试机制保证每次接口变更都能测试到所有相关层面。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;写在最后&lt;/h3&gt;

&lt;p&gt;关于接口设计，暂时想到的就这么多了。各位看官看完觉得有遗漏或有哪些需要优化的欢迎提出一起讨论。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;博主对本文写的观点深表赞同，并且目前的项目也在用同样的接口设计，本文总结的很好，遂转于本博予以收藏，如有侵犯版权问题，请与本博主联系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;转载自Keegan小钢&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;原文链接：http://keeganlee.me/post/architecture/20160107&lt;/em&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/24/App%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%BB%8F%E9%AA%8C%E8%B0%88-%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/24/App%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%BB%8F%E9%AA%8C%E8%B0%88-%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
        
        <category>Francis 杂谈</category>
        
        <category>架构</category>
        
        
      </item>
    
      <item>
        <title>如何评价『黑客与画家』</title>
        <description>&lt;p&gt;一本好的书，让我们收获的不单单是某种技巧，或者某种方法论， &lt;strong&gt;他教给我们的是一种严密的思维方式，是一种学会把自己的眼光放得更加长远的决策习惯，他促使我们养成独立思考的习惯。&lt;/strong&gt; 他没有送给我们一条大鱼，却把捕捉大鱼的方法交给了我们， &lt;strong&gt;授人以鱼，不如授人以渔&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我一直觉得把一个我们所熟知的很普通的问题讲的非常透彻而且非常清楚是一种相当了不起的能力， 保罗·格雷尔姆 不仅把问题讲的非常透彻，而且还非常有趣， 让我们在读的时候感觉趣味盎然，这一点是非常不容易的。&lt;/p&gt;

&lt;p&gt;很多的互联网从业者想必早就听说过这本书，而且大部分人应该都已经阅读过这本书了， 所以我就简单的从其他的角度来谈一下我读完本书的一些感想，希望对大家有所帮助。&lt;/p&gt;

&lt;p&gt;在阅读「为什么书呆子不受欢迎」这章时，我想到了这么一句话，&lt;strong&gt;「你的时间在哪里，你的成就就在哪里」&lt;/strong&gt;。 生活中的我们，总是喜欢羡慕那些成功人士，我们总觉得那些成功人士与我们普通人不一样， 他们必然懂得某种通往成功的诀窍，他们生下来就与周围的人们有所不同。 我们也总是希望能从这些成功人士那里获得某些珍贵的建议，获得那些能使人最终功成名就的万用妙方。 在武侠小说里面， &lt;strong&gt;渴望成为武林高手的人，都希望得到一本有着盖世神功的武林秘籍&lt;/strong&gt;。 因为这秘籍一旦得手，只要依葫芦画瓢，就可大功告成。&lt;/p&gt;

&lt;p&gt;但是世事又怎会如此简单，也永远不会有这样或者那样的武林秘诀。 &lt;strong&gt;所谓的成功人士不过是把自己的时间投入到那些他们感兴趣的领域里面罢了&lt;/strong&gt;。 其实， &lt;strong&gt;我们每一个人也许都是我们所投入时间的那个领域的成功人士&lt;/strong&gt;。 有的同学，可能在学校里没有把时间投入学习中，但是呢，投入了很多的时间在游戏领域，每天花费大量的时间去玩游戏， 看游戏讲解视频，研究游戏的战略，思考游戏的玩法，在这个游戏里面，他就是王者； 有的人呢，可能喜欢计算机，他喜欢与程序打交道，他希望了解计算机是如何思考的，于是最终他就成了黑客。&lt;/p&gt;

&lt;p&gt;画家能够把画画的比我们更好，只是因为他把他的时间都投入到里面罢了，田径运动员跑的比我们更快， 同样只不过因为他把他的时间都投入到跑步里面罢了。 &lt;strong&gt;书呆子也并非不想让自己不受欢迎，他们只是更愿意把时间投入到让自己聪明上去罢了&lt;/strong&gt;。 我们每一个人，都可以自己去决定把自己的时间投入到哪个领域，我们所投入的时间最终也会成就我们。&lt;/p&gt;

&lt;p&gt;在阅读本书的其他章节的时候，我更加深刻的发觉，黑客们，其实与我们并没有多大的不同， &lt;strong&gt;他们只是比我们普通人更加崇尚分享、开放和民主，他们对任何被禁止的东西都怀有特别强烈的好奇心，他们喜欢去思考那些似乎不应该被思考的问题，他们相信计算机将会深刻的改变人们的生活&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;虽然这是一本讲述黑客的书，不过个人觉得每个人都应该看看。 如同译者阮一峰所言：未来的人类生活不仅是人与人的互动，而且更多的将是人与计算机的互动。 想要把握这个时代，就必须理解计算机。 理解计算机的关键，则是要理解计算机背后的人。 表面上这是一个机器的时代，但是实际上机器的设计者决定了我们的时代。 &lt;strong&gt;程序员的审美决定了你看到的软件界面，程序员的爱好决定了你有什么样的软件可以使用&lt;/strong&gt;。&lt;/p&gt;

</description>
        <pubDate>Thu, 24 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/24/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/24/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/</guid>
        
        <category>Francis 杂谈</category>
        
        <category>读书笔记</category>
        
        
      </item>
    
      <item>
        <title>[福利]如何下载Tumblr的视频</title>
        <description>&lt;p&gt;众所周知，Tumblr是Yahoo旗下的轻博客，可以让使用者写日志，也能上传视频，那如果你把视频上传后想要下载下来怎么办呢？右键好像无法另存，不用担心，现在透过线上服务也能将Tumblr上的视频轻松下载下来保存，以免Tumblr服务停止运营后，视频不知道怎么备份下来！&lt;/p&gt;

&lt;p&gt;透过国外的&lt;a href=&quot;http://www.tubeoffline.com/&quot;&gt;TubeOffline&lt;/a&gt;，只要将Tumblr的单篇文章网址(内含视频的)粘贴上去，就能轻松下载Tumblr视频并存成mp4格式，完全不需要任何软件，只要透过浏览器就可以轻松抓Tumblr视频。通常在抓视频比较不建议去安装软件，毕竟抓视频不一定是常常会用到，安装软件又会占用电脑资源，实在是不划算。透过线上服务可以轻松获取就利用线上服务吧！&lt;/p&gt;

&lt;p&gt;透过TubeOffline的线上服务只是帮助你从Tumblr视频页面的源代码中找出实际影片的地址而已，毕竟现在有些机制或者是要加速网站速度，都不会使用传统的一个完整的视频网址让大家可以直接抓，都会透过程序分割或者是隐藏，一般使用者并不一定能看懂源代码，但透过TubeOffline就可以轻松抓取。&lt;/p&gt;

&lt;h2 id=&quot;tumblrhttpsourcefrancissoungcom20162f032f212fe5a682e4bd95e4b88be8bdbdtumblre4b88ae79a84e8a786e9a2911png&quot;&gt;&lt;img src=&quot;http://source.francissoung.com/2016%2F03%2F21%2F%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BDTumblr%E4%B8%8A%E7%9A%84%E8%A7%86%E9%A2%911.png&quot; alt=&quot;如何下载Tumblr的视频&quot; /&gt;&lt;/h2&gt;

&lt;p&gt;网站名称：TubeOffline&lt;/p&gt;

&lt;p&gt;网站地址：&lt;a href=&quot;http://www.tubeoffline.com/download-tumblr-videos.php&quot;&gt;点这里&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;第1步  依照TubeOffline官方提供的示例视频网址，你可以试试看将网址粘贴到「video URL」的输入框，并尝试点下﹝Get Video﹞就可以取得影片网址了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://source.francissoung.com/2016%2F03%2F21%2F%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BDTumblr%E7%9A%84%E8%A7%86%E9%A2%912.jpg&quot; alt=&quot;如何下载Tumblr的视频&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第2步  接著只要点击﹝Download﹞就可以把Tumblr视频下载下来了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://source.francissoung.com/2016%2F03%2F21%2F%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BDTumblr%E7%9A%84%E8%A7%86%E9%A2%913.jpg&quot; alt=&quot;如何下载Tumblr的视频&quot; /&gt;&lt;/p&gt;

&lt;p&gt;快行动吧,福利已经奉上,拿出你的右手.&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/23/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BDTumblr%E7%9A%84%E8%A7%86%E9%A2%91/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/23/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BDTumblr%E7%9A%84%E8%A7%86%E9%A2%91/</guid>
        
        <category>Francis 杂谈</category>
        
        
      </item>
    
      <item>
        <title>如何减少接口响应时间</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Premature optimization is the root of all evil.&lt;/p&gt;

  &lt;p&gt;　 — Donald Knuth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于程序优化，我一直采取保守的态度，除非万不得已。但是随着业务的不断发展，程序越来越复杂，代码越写越多，优化似乎是终有一天会到来的事情。&lt;/p&gt;

&lt;p&gt;那么对于一个典型的后台服务接口，我们可以从那些方面入手进行优化呢？&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;接口拆分&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;接口垂直拆分&lt;/h3&gt;

&lt;p&gt;垂直拆分可以简单理解为微服务化，把一个大而复杂的服务拆分成多个相互独立，职能单一的服务，单独部署。 更细粒度拆分的好处是，能对某个具体的微服务进行特殊优化，以最大的投入产出比来解决整个服务的性能。 垂直拆分还有一个好处是，对于非必须的接口，可以很方便的进行降级处理，把坏影响隔离到核心逻辑外部。 最容易想到的优化办法是把某个对整体性能有决定性影响的微服务接口进行水平扩容。&lt;/p&gt;

&lt;p&gt;注意: 拆分后必定会增加外部接口调用，多少会有些额外开销，但是对于有限几个调用，拆分的还是值得的。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;接口水平拆分&lt;/h3&gt;

&lt;p&gt;这里说的水平拆分一定不是把一个接口部署更多份，因为这样只能解决接口的容量问题，但是不能减少接口的响应时间。 水平拆分可以简单理解成mapreduce模型，把整个计算逻辑或者数据平均分配到集群中的N个服务器去，然后由一台机器去并发调用并做结果合并。 理论上这种方式能把响应减少到1/N+合并+调用开销的时间。&lt;/p&gt;

&lt;p&gt;注意： 一个问题需要考虑的是，如果并发调用的接口返回的数据量比较大，可能会对合并机器的网络负载和数据序列化(CPU)有一定影响。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;缓存&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;接口缓存&lt;/h3&gt;

&lt;p&gt;一个有着复杂逻辑或者大量计算数据的接口，能对整个结果进行缓存再好不过了。缓存针对不同的场景会有多种策略，对于有大量并发请求的场景， 推荐一个方案：一种基于“哨兵”的分布式缓存设计，不会有损失第一个用户，也不会有定时更新缓存的额外开销。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;本地缓存&lt;/h3&gt;

&lt;p&gt;本地缓存有两种场景，对于类似字典类型的数据，可以静态化后放入内存，定时去刷新或者采用通知机制去更新。&lt;/p&gt;

&lt;p&gt;还有一种场景是用ThreadLocal缓存重复内部计算与重复的对象创建； 对于链路比较长或者循环比较深的接口，ThreadLocal减少重复计算和对象创建，从而降低RT和节约内存。&lt;/p&gt;

&lt;p&gt;注意： 在有内部并发的地方使用ThreadLocal一定要注意不同线程间的数据同步。主线程的ThreadLocal数据和每个并发子线程的ThreadLocal数据要同步好。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;内部优化&lt;/h2&gt;

&lt;h3 id=&quot;section-7&quot;&gt;非核心流程异步化&lt;/h3&gt;

&lt;p&gt;类似于发消息，写日志，更新缓存等不会影响接口准确性的非核心流程，可以采用异步方式进行处理，不阻塞主计算逻辑处理。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;内部并发&lt;/h3&gt;

&lt;p&gt;如果进行水平拆分后，并发调用IO较大，可以考虑换成内部并发解决IO问题。如果内部并发涉及到每个线程更新同一个集合数据，不用忘了使用线程安全的集合。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;优化一定不是一蹴而就的，整个优化过程是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;统计--&amp;gt;方案--&amp;gt;验证&lt;/code&gt;的闭环，需要不断试错，不断挖掘，最终达到预期。&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/16/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/16/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/</guid>
        
        <category>Francis 杂谈</category>
        
        <category>编程</category>
        
        
      </item>
    
      <item>
        <title>PHP超时处理全面总结</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;在PHP开发中工作里非常多使用到超时处理到超时的场合，我说几个场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;异步获取数据如果某个后端数据源获取不成功则跳过，不影响整个页面展现&lt;/li&gt;
  &lt;li&gt;为了保证Web服务器不会因为当个页面处理性能差而导致无法访问其他页面，则会对某些页面操作设置&lt;/li&gt;
  &lt;li&gt;对于某些上传或者不确定处理时间的场合，则需要对整个流程中所有超时设置为无限，否则任何一个环节设置不当，都会导致莫名执行中断&lt;/li&gt;
  &lt;li&gt;多个后端模块（MySQL、Memcached、HTTP接口），为了防止单个接口性能太差，导致整个前面获取数据太缓慢，影响页面打开速度，引起雪崩&lt;/li&gt;
  &lt;li&gt;。。。很多需要超时的场合&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些地方都需要考虑超时的设定，但是PHP中的超时都是分门别类，各个处理方式和策略都不同，为了系统的描述，我总结了PHP中常用的超时处理的总结。&lt;/p&gt;

&lt;h2 id=&quot;web&quot;&gt;Web服务器超时处理&lt;/h2&gt;

&lt;h3 id=&quot;apache&quot;&gt;Apache&lt;/h3&gt;

&lt;p&gt;一般在性能很高的情况下，缺省所有超时配置都是30秒，但是在上传文件，或者网络速度很慢的情况下，那么可能触发超时操作。&lt;/p&gt;

&lt;p&gt;目前apachefastcgiphp-fpm模式下有三个超时设置：&lt;/p&gt;

&lt;p&gt;fastcgi超时设置：&lt;/p&gt;

&lt;p&gt;修改httpd.conf的fastcgi连接配置，类似如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;IfModulemod_fastcgi.c&amp;gt;FastCgiExternalServer/home/forum/apache/apache_php/cgi-bin/php-cgi-socket/home/forum/php5/etc/php-fpm.sock
ScriptAlias/fcgi-bin/”/home/forum/apache/apache_php/cgi-bin/”

AddHandlerphp-fastcgi.php

Actionphp-fastcgi/fcgi-bin/php-cgi

AddTypeapplication/x-httpd-php.php

&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;缺省配置是30s，如果需要定制自己的配置，需要修改配置，比如修改为100秒：(修改后重启apache)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;IfModulemod_fastcgi.c&amp;gt;
FastCgiExternalServer/home/forum/apache/apache_php/cgi-bin/php-cgi-socket/home/forum/php5/etc/php-fpm.sock-idle-timeout100

ScriptAlias/fcgi-bin/”/home/forum/apache/apache_php/cgi-bin/”

AddHandlerphp-fastcgi.php

Actionphp-fastcgi/fcgi-bin/php-cgi

AddTypeapplication/x-httpd-php.php

&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果超时会返回500错误，断开跟后端php服务的连接，同时记录一条apache错误日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ThuJan2718:30:152011][error][client10.81.41.110]FastCGI:commwithserver”/home/forum/apache/apache_php/cgi-bin/php-cgi”aborted:idletimeout(30sec)

[ThuJan2718:30:152011][error][client10.81.41.110]FastCGI:incompleteheaders(0bytes)receivedfromserver”/home/forum/apache/apache_php/cgi-bin/php-cgi”
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他fastcgi配置参数说明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IdleTimeout发呆时限ProcessLifeTime一个进程的最长生命周期，过期之后无条件kill
MaxProcessCount最大进程个数
DefaultMinClassProcessCount每个程序启动的最小进程个数
DefaultMaxClassProcessCount每个程序启动的最大进程个数
IPCConnectTimeout程序响应超时时间
IPCCommTimeout与程序通讯的最长时间，上面的错误有可能就是这个值设置过小造成的
MaxRequestsPerProcess每个进程最多完成处理个数，达成后自杀
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;lighttpd&quot;&gt;Lighttpd&lt;/h3&gt;

&lt;p&gt;配置：lighttpd.conf&lt;/p&gt;

&lt;p&gt;Lighttpd配置中，关于超时的参数有如下几个（篇幅考虑，只写读超时，写超时参数同理）：&lt;/p&gt;

&lt;p&gt;主要涉及选项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server.max-keep-alive-idle=5
server.max-read-idle=60
server.read-timeout=0
server.max-connection-idle=360

————————————————–

#每次keep-alive的最大请求数,默认值是16

server.max-keep-alive-requests=100

#keep-alive的最长等待时间,单位是秒，默认值是5

server.max-keep-alive-idle=1200

#lighttpd的work子进程数，默认值是0，单进程运行

server.max-worker=2

#限制用户在发送请求的过程中，最大的中间停顿时间(单位是秒)，

#如果用户在发送请求的过程中(没发完请求)，中间停顿的时间太长，lighttpd会主动断开连接

#默认值是60(秒)

server.max-read-idle=1200

#限制用户在接收应答的过程中，最大的中间停顿时间(单位是秒)，

#如果用户在接收应答的过程中(没接完)，中间停顿的时间太长，lighttpd会主动断开连接

#默认值是360(秒)

server.max-write-idle=12000

#读客户端请求的超时限制，单位是秒,配为0表示不作限制

#设置小于max-read-idle时，read-timeout生效

server.read-timeout=0

#写应答页面给客户端的超时限制，单位是秒，配为0表示不作限制

#设置小于max-write-idle时，write-timeout生效

server.write-timeout=0

#请求的处理时间上限，如果用了mod_proxy_core，那就是和后端的交互时间限制,单位是秒

server.max-connection-idle=1200

————————————————–
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;对于一个keep-alive连接上的连续请求，发送第一个请求内容的最大间隔由参数max-read-idle决定，从第二个请求起，发送请求内容的最大间隔由参数max-keep-alive-idle决定。请求间的间隔超时也由max-keep-alive-idle决定。发送请求内容的总时间超时由参数read-timeout决定。Lighttpd与后端交互数据的超时由max-connection-idle决定。&lt;/p&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;http://www.snooda.com/read/244&lt;/p&gt;

&lt;h3 id=&quot;nginx&quot;&gt;Nginx&lt;/h3&gt;

&lt;p&gt;配置：nginx.conf&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http{
#Fastcgi:(针对后端的fastcgi生效,fastcgi不属于proxy模式)

fastcgi_connect_timeout5;#连接超时

fastcgi_send_timeout10; #写超时

fastcgi_read_timeout10;#读取超时

#Proxy:(针对proxy/upstreams的生效)

proxy_connect_timeout15s;#连接超时

proxy_read_timeout24s;#读超时

proxy_send_timeout10s; #写超时

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;Nginx 的超时设置倒是非常清晰容易理解，上面超时针对不同工作模式，但是因为超时带来的问题是非常多的。&lt;/p&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://hi.baidu.com/pibuchou/blog/item/a1e330dd71fb8a5995ee3753.html&quot;&gt;http://hi.baidu.com/pibuchou/blog/item/a1e330dd71fb8a5995ee3753.html &lt;/a&gt; 
&lt;a href=&quot;http://hi.baidu.com/pibuchou/blog/item/7cbccff0a3b77dc60b46e024.html&quot;&gt;http://hi.baidu.com/pibuchou/blog/item/7cbccff0a3b77dc60b46e024.html &lt;/a&gt; 
&lt;a href=&quot;http://hi.baidu.com/pibuchou/blog/item/10a549818f7e4c9df703a626.html&quot;&gt;http://hi.baidu.com/pibuchou/blog/item/10a549818f7e4c9df703a626.html &lt;/a&gt; 
&lt;a href=&quot;http://www.apoyl.com/?p=466&quot;&gt;http://www.apoyl.com/?p=466  &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;php&quot;&gt;PHP本身超时处理&lt;/h2&gt;

&lt;h3 id=&quot;php-fpm&quot;&gt;PHP-fpm&lt;/h3&gt;

&lt;p&gt;配置：php-fpm.conf&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xmlversion=”1.0″?&amp;gt;
&amp;lt;configuration&amp;gt;

//…

Setsthelimitonthenumberofsimultaneousrequeststhatwillbeserved.

EquivalenttoApacheMaxClientsdirective.

EquivalenttoPHP_FCGI_CHILDRENenvironmentinoriginalphp.fcgi

Usedwithanypm_style.

#php-cgi的进程数量

&amp;lt;valuename=”max_children”&amp;gt;128&amp;lt;/value&amp;gt;

Thetimeout(inseconds)forservingasinglerequestafterwhichtheworkerprocesswillbeterminated

Shouldbeusedwhen’max_execution_time’inioptiondoesnotstopscriptexecutionforsomereason

’0s’means’off’

#php-fpm 请求执行超时时间，0s为永不超时，否则设置一个 Ns 为超时的秒数

&amp;lt;valuename=”request_terminate_timeout”&amp;gt;0s&amp;lt;/value&amp;gt;

Thetimeout(inseconds)forservingofsinglerequestafterwhichaphpbacktracewillbedumpedtoslow.logfile

’0s’means’off’

&amp;lt;valuename=”request_slowlog_timeout”&amp;gt;0s&amp;lt;/value&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;在php.ini中，有一个参数max_execution_time可以设置PHP脚本的最大执行时间，但是，在php-cgi(php-fpm)中，该参数不会起效。真正能够控制PHP脚本最大执行时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;valuename=”request_terminate_timeout”&amp;gt;0s&amp;lt;/value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就是说如果是使用mod_php5.so的模式运行max_execution_time是会生效的，但是如果是php-fpm模式中运行时不生效的。&lt;/p&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;http://blog.s135.com/file_get_contents/&lt;/p&gt;

&lt;h3 id=&quot;php-1&quot;&gt;PHP&lt;/h3&gt;

&lt;p&gt;配置：php.ini&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;max_execution_time=30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者在代码里设置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ini_set(“max_execution_time”,30);

set_time_limit(30);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;对当前会话生效，比如设置0一直不超时，但是如果php的safe_mode打开了，这些设置都会不生效。&lt;/p&gt;

&lt;p&gt;效果一样，但是具体内容需要参考php-fpm部分内容，如果php-fpm中设置了request_terminate_timeout的话，那么max_execution_time就不生效。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;后端&amp;amp;接口访问超时&lt;/h2&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP访问&lt;/h2&gt;

&lt;p&gt;一般我们访问HTTP方式很多，主要是：curl,socket,file_get_contents()等方法。&lt;/p&gt;

&lt;p&gt;如果碰到对方服务器一直没有响应的时候，我们就悲剧了，很容易把整个服务器搞死，所以在访问http的时候也需要考虑超时的问题。&lt;/p&gt;

&lt;h3 id=&quot;curl-http&quot;&gt;CURL 访问HTTP&lt;/h3&gt;

&lt;p&gt;CURL 是我们常用的一种比较靠谱的访问HTTP协议接口的lib库，性能高，还有一些并发支持的功能等。&lt;/p&gt;

&lt;p&gt;CURL:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl_setopt($ch,opt)可以设置一些超时的设置，主要包括：

*(重要)CURLOPT_TIMEOUT设置cURL允许执行的最长秒数。

*(重要)CURLOPT_TIMEOUT_MS设置cURL允许执行的最长毫秒数。(在cURL7.16.2中被加入。从PHP5.2.3起可使用。)

CURLOPT_CONNECTTIMEOUT在发起连接前等待的时间，如果设置为0，则无限等待。

CURLOPT_CONNECTTIMEOUT_MS尝试连接等待的时间，以毫秒为单位。如果设置为0，则无限等待。在cURL7.16.2中被加入。从PHP5.2.3开始可用。

CURLOPT_DNS_CACHE_TIMEOUT设置在内存中保存DNS信息的时间，默认为120秒。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;curl普通秒级超时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ch=curl_init();

curl_setopt($ch,CURLOPT_URL,$url);

curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);

curl_setopt($ch,CURLOPT_TIMEOUT,60);//只需要设置一个秒的数量就可以

curl_setopt($ch,CURLOPT_HTTPHEADER,$headers);

curl_setopt($ch,CURLOPT_USERAGENT,$defined_vars[&#39;HTTP_USER_AGENT&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;curl普通秒级超时使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl_setopt($ch,CURLOPT_TIMEOUT,60);

curl如果需要进行毫秒超时，需要增加：

curl_easy_setopt(curl,CURLOPT_NOSIGNAL,1L);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl_setopt($ch,CURLOPT_NOSIGNAL,true);是可以支持毫秒级别超时设置的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;curl一个毫秒级超时的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
if(!isset($_GET[&#39;foo&#39;])){

//Client

$ch=curl_init(‘http://example.com/’);

curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);

curl_setopt($ch,CURLOPT_NOSIGNAL,1);//注意，毫秒超时一定要设置这个

curl_setopt($ch,CURLOPT_TIMEOUT_MS,200);//超时毫秒，cURL7.16.2中被加入。从PHP5.2.3起可使用

$data=curl_exec($ch);

$curl_errno=curl_errno($ch);

$curl_error=curl_error($ch);

curl_close($ch);

if($curl_errno&amp;gt;0){

echo”cURLError($curl_errno):$curl_errorn”;

}else{

echo”Datareceived:$datan”;

}

}else{

//Server

sleep(10);

echo”Done.”;

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他一些技巧：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;按照经验总结是：cURL版本&amp;gt;=libcurl/7.21.0版本，毫秒级超时是一定生效的，切记。&lt;/li&gt;
  &lt;li&gt;curl_multi的毫秒级超时也有问题。。单次访问是支持ms级超时的，curl_multi并行调多个会不准&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;http-1&quot;&gt;流处理方式访问HTTP&lt;/h3&gt;

&lt;p&gt;除了curl，我们还经常自己使用fsockopen、或者是file操作函数来进行HTTP协议的处理，所以，我们对这块的超时处理也是必须的。&lt;/p&gt;

&lt;p&gt;一般连接超时可以直接设置，但是流读取超时需要单独处理。&lt;/p&gt;

&lt;p&gt;自己写代码处理:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$tmCurrent=gettimeofday();

$intUSGone=($tmCurrent[&#39;sec&#39;]-$tmStart[&#39;sec&#39;])*1000000

+($tmCurrent[&#39;usec&#39;]-$tmStart[&#39;usec&#39;]);

if($intUSGone&amp;gt;$this-&amp;gt;_intReadTimeoutUS){

returnfalse;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者使用内置流处理函数stream_set_timeout()和stream_get_meta_data()处理：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php//Timeoutinseconds
$timeout=5;

$fp=fsockopen(“example.com”,80,$errno,$errstr,$timeout);

if($fp){

fwrite($fp,”GET/HTTP/1.0rn”);

fwrite($fp,”Host:example.comrn”);

fwrite($fp,”Connection:Closernrn”);

stream_set_blocking($fp,true);//重要，设置为非阻塞模式

stream_set_timeout($fp,$timeout);//设置超时

$info=stream_get_meta_data($fp);

while((!feof($fp))&amp;amp;&amp;amp;(!$info[&#39;timed_out&#39;])){

$data.=fgets($fp,4096);

$info=stream_get_meta_data($fp);

ob_flush;

flush();

}

if($info[&#39;timed_out&#39;]){

echo”ConnectionTimedOut!”;

}else{

echo$data;

}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;file_get_contents超时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php$timeout=array(
&#39;http=&amp;gt;array(

&#39;timeout&#39;=&amp;gt;5//设置一个超时时间，单位为秒

)

);

$ctx=stream_context_create($timeout);

$text=file_get_contents(&quot;http://example.com/&quot;,0,$ctx);

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;fopen超时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php$timeout=array(
&#39;http&#39;=&amp;gt;array(

&#39;timeout&#39;=&amp;gt;5//设置一个超时时间，单位为秒

)

);

$ctx=stream_context_create($timeout);

if($fp=fopen(&quot;http://example.com/&quot;,&quot;r&quot;,false,$ctx)){

while($c=fread($fp,8192)){

echo$c;

}

fclose($fp);

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL&lt;/h2&gt;

&lt;p&gt;php中的mysql客户端都没有设置超时的选项，mysqli和mysql都没有，但是libmysql是提供超时选项的，只是我们在php中隐藏了而已。&lt;/p&gt;

&lt;p&gt;那么如何在PHP中使用这个操作捏，就需要我们自己定义一些MySQL操作常量，主要涉及的常量有：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MYSQL_OPT_READ_TIMEOUT=11;

MYSQL_OPT_WRITE_TIMEOUT=12;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这两个，定义以后，可以使用options设置相应的值。&lt;/p&gt;

&lt;p&gt;不过有个注意点，mysql内部实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;超时设置单位为秒，最少配置1秒&lt;/li&gt;
  &lt;li&gt;但mysql底层的read会重试两次，所以实际会是3秒&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;重试两次+　自身一次=3倍超时时间，那么就是说最少超时时间是3秒，不会低于这个值，对于大部分应用来说可以接受，但是对于小部分应用需要优化。&lt;/p&gt;

&lt;p&gt;查看一个设置访问mysql超时的php实例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php//自己定义读写超时常量
if(!defined(‘MYSQL_OPT_READ_TIMEOUT’)){

define(‘MYSQL_OPT_READ_TIMEOUT’,11);

}

if(!defined(‘MYSQL_OPT_WRITE_TIMEOUT’)){

define(‘MYSQL_OPT_WRITE_TIMEOUT’,12);

}

//设置超时

$mysqli=mysqli_init();

$mysqli-&amp;gt;options(MYSQL_OPT_READ_TIMEOUT,3);

$mysqli-&amp;gt;options(MYSQL_OPT_WRITE_TIMEOUT,1);

//连接数据库

$mysqli-&amp;gt;real_connect(“localhost”,”root”,”root”,”test”);

if(mysqli_connect_errno()){

printf(“Connectfailed:%s/n”,mysqli_connect_error());

exit();

}

//执行查询sleep1秒不超时

printf(“Hostinformation:%s/n”,$mysqli-&amp;gt;host_info);

if(!($res=$mysqli-&amp;gt;query(‘selectsleep(1)’))){

echo”query1error:”.$mysqli-&amp;gt;error.”/n”;

}else{

echo”Query1:querysuccess/n”;

}

//执行查询sleep9秒会超时

if(!($res=$mysqli-&amp;gt;query(‘selectsleep(9)’))){

echo”query2error:”.$mysqli-&amp;gt;error.”/n”;

}else{

echo”Query2:querysuccess/n”;

}

$mysqli-&amp;gt;close();

echo”closemysqlconnection/n”;

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/heiyeshuwu/article/details/5869813&quot;&gt;http://blog.csdn.net/heiyeshuwu/article/details/5869813&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;memcached&quot;&gt;Memcached&lt;/h2&gt;

&lt;h3 id=&quot;php-2&quot;&gt;PHP扩展&lt;/h3&gt;

&lt;p&gt;php_memcache客户端：&lt;/p&gt;

&lt;p&gt;连接超时：&lt;code class=&quot;highlighter-rouge&quot;&gt;boolMemcache::connect(string$host[,int$port[,int$timeout]])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在get和set的时候，都没有明确的超时设置参数。&lt;/p&gt;

&lt;p&gt;libmemcached客户端：在php接口没有明显的超时参数。&lt;/p&gt;

&lt;p&gt;说明：所以说，在PHP中访问Memcached是存在很多问题的，需要自己hack部分操作，或者是参考网上补丁。&lt;/p&gt;

&lt;h3 id=&quot;ccmemcached&quot;&gt;C&amp;amp;C++访问Memcached&lt;/h3&gt;

&lt;p&gt;客户端：libmemcached客户端&lt;/p&gt;

&lt;p&gt;说明：memcache超时配置可以配置小点，比如5，10个毫秒已经够用了，超过这个时间还不如从数据库查询。&lt;/p&gt;

&lt;p&gt;下面是一个连接和读取set数据的超时的C++示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//创建连接超时（连接到Memcached）
memcached_st*MemCacheProxy::_create_handle()

{

memcached_st*mmc=NULL;

memcached_return_tprc;

if(_mpool!=NULL){//getfrompool

mmc=memcached_pool_pop(_mpool,false,&amp;amp;prc);

if(mmc==NULL){

__LOG_WARNING__(“MemCacheProxy”,”gethandlefrompoolerror[%d]“,(int)prc);

}

returnmmc;

}

memcached_st*handle=memcached_create(NULL);

if(handle==NULL){

__LOG_WARNING__(“MemCacheProxy”,”create_handleerror”);

returnNULL;

}

//设置连接/读取超时

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_HASH,MEMCACHED_HASH_DEFAULT);

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_NO_BLOCK,_noblock);//参数MEMCACHED_BEHAVIOR_NO_BLOCK为1使超时配置生效，不设置超时会不生效，关键时候会悲剧的，容易引起雪崩

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT,_connect_timeout);//连接超时

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_RCV_TIMEOUT,_read_timeout);//读超时

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_SND_TIMEOUT,_send_timeout);//写超时

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_POLL_TIMEOUT,_poll_timeout);

//设置一致hash

//memcached_behavior_set_distribution(handle,MEMCACHED_DISTRIBUTION_CONSISTENT);

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_DISTRIBUTION,MEMCACHED_DISTRIBUTION_CONSISTENT);

memcached_returnrc;

for(uinti=0;i&amp;lt;_server_count;i++){

rc=memcached_server_add(handle,_ips[i],_ports[i]);

if(MEMCACHED_SUCCESS!=rc){

__LOG_WARNING__(“MemCacheProxy”,”addserver[%s:%d]failed.”,_ips[i],_ports[i]);

}

}

_mpool=memcached_pool_create(handle,_min_connect,_max_connect);

if(_mpool==NULL){

__LOG_WARNING__(“MemCacheProxy”,”create_poolerror”);

returnNULL;

}

mmc=memcached_pool_pop(_mpool,false,&amp;amp;prc);

if(mmc==NULL){

__LOG_WARNING__(“MyMemCacheProxy”,”gethandlefrompoolerror[%d]“,(int)prc);

}

//__LOG_DEBUG__(“MemCacheProxy”,”gethandle[%p]“,handle);

returnmmc;

}

//设置一个key超时（set一个数据到memcached）

boolMemCacheProxy::_add(memcached_st*handle,unsignedint*key,constchar*value,intlen,unsignedinttimeout)

{

memcached_returnrc;

chartmp[1024];

snprintf(tmp,sizeof(tmp),”%u#%u”,key[0],key[1]);

//有个timeout值

rc=memcached_set(handle,tmp,strlen(tmp),(char*)value,len,timeout,0);

if(MEMCACHED_SUCCESS!=rc){

returnfalse;

}

returntrue;

}

//Memcache读取数据超时(没有设置)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;libmemcahed源码中接口定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LIBMEMCACHED_APIchar*memcached_get(memcached_st*ptr,constchar*key,size_tkey_length,size_t*value_length,uint32_t*flags,memcached_return_t*error);

LIBMEMCACHED_APImemcached_return_tmemcached_mget(memcached_st*ptr,constchar*const*keys,constsize_t*key_length,size_tnumber_of_keys);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从接口中可以看出在读取数据的时候，是没有超时设置的。&lt;/p&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://hi.baidu.com/chinauser/item/b30af90b23335dde73e67608&quot;&gt;http://hi.baidu.com/chinauser/item/b30af90b23335dde73e67608  &lt;/a&gt;
&lt;a href=&quot;http://libmemcached.org/libMemcached.html&quot;&gt;http://libmemcached.org/libMemcached.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;如何实现超时&lt;/h2&gt;

&lt;p&gt;程序中需要有超时这种功能，比如你单独访问一个后端Socket模块，Socket模块不属于我们上面描述的任何一种的时候，它的协议也是私有的，那么这个时候可能需要自己去实现一些超时处理策略，这个时候就需要一些处理代码了。&lt;/p&gt;

&lt;h3 id=&quot;php-3&quot;&gt;PHP中超时实现&lt;/h3&gt;

&lt;p&gt;一、初级：最简单的超时实现 （秒级超时）&lt;/p&gt;

&lt;p&gt;思路很简单：链接一个后端，然后设置为非阻塞模式，如果没有连接上就一直循环，判断当前时间和超时时间之间的差异。&lt;/p&gt;

&lt;p&gt;phpsocket中实现原始的超时：(每次循环都当前时间去减，性能会很差，cpu占用会较高)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?$host=”127.0.0.1″;
$port=”80″;

$timeout=15;//timeoutinseconds

$socket=socket_create(AF_INET,SOCK_STREAM,SOL_TCP)

ordie(“Unabletocreatesocketn”);

socket_set_nonblock($socket) //务必设置为阻塞模式

ordie(“Unabletosetnonblockonsocketn”);

$time=time();

//循环的时候每次都减去相应值

while(!@socket_connect($socket,$host,$port))//如果没有连接上就一直死循环

{

$err=socket_last_error($socket);

if($err==115||$err==114)

{

if((time()-$time)&amp;gt;=$timeout)//每次都需要去判断一下是否超时了

{

socket_close($socket);

die(“Connectiontimedout.n”);

}

sleep(1);

continue;

}

die(socket_strerror($err).”n”);

}

socket_set_block($this-&amp;gt;socket)//还原阻塞模式

ordie(“Unabletosetblockonsocketn”);

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;二、升级：使用PHP自带异步IO去实现（毫秒级超时）&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;异步IO：异步IO的概念和同步IO相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。异步IO将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方从不知道它们会在什么时候到达。&lt;/p&gt;

&lt;p&gt;多路复用：复用模型是对多个IO操作进行检测，返回可操作集合，这样就可以对其进行操作了。这样就避免了阻塞IO不能随时处理各个IO和非阻塞占用系统资源的确定。&lt;/p&gt;

&lt;p&gt;使用socket_select()实现超时&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;socket_select(…,floor($timeout),ceil($timeout*1000000));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;select的特点：能够设置到微秒级别的超时！&lt;/p&gt;

&lt;p&gt;使用socket_select()的超时代码（需要了解一些异步IO编程的知识去理解）&lt;/p&gt;

&lt;p&gt;编程 调用类 编程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

$server=newServer;

$client=newClient;

for(;;){

foreach($select-&amp;gt;can_read(0)as$socket){

if($socket==$client-&amp;gt;socket){

//NewClientSocket

$select-&amp;gt;add(socket_accept($client-&amp;gt;socket));

}

else{

//there’ssomethingtoreadon$socket

}

}

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编程 异步多路复用IO &amp;amp; 超时连接处理类 编程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

classselect{

var$sockets;

functionselect($sockets){

$this-&amp;gt;sockets=array();

foreach($socketsas$socket){

$this-&amp;gt;add($socket);

}

}

functionadd($add_socket){

array_push($this-&amp;gt;sockets,$add_socket);

}

functionremove($remove_socket){

$sockets=array();

foreach($this-&amp;gt;socketsas$socket){

if($remove_socket!=$socket)

$sockets[]=$socket;

}

$this-&amp;gt;sockets=$sockets;

}

functioncan_read($timeout){

$read=$this-&amp;gt;sockets;

socket_select($read,$write=NULL,$except=NULL,$timeout);

return$read;

}

functioncan_write($timeout){

$write=$this-&amp;gt;sockets;

socket_select($read=NULL,$write,$except=NULL,$timeout);

return$write;

}

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cc&quot;&gt;C&amp;amp;C++中超时实现&lt;/h3&gt;

&lt;p&gt;一般在LinuxC/C++中，可以使用：alarm()设置定时器的方式实现秒级超时，或者：select()、poll()、epoll()之类的异步复用IO实现毫秒级超时。也可以使用二次封装的异步io库（libevent,libev）也能实现。&lt;/p&gt;

&lt;p&gt;一、使用alarm中用信号实现超时 （秒级超时）&lt;/p&gt;

&lt;p&gt;说明：Linux内核connect超时通常为75秒，我们可以设置更小的时间如10秒来提前从connect中返回。这里用使用信号处理机制，调用alarm，超时后产生SIGALRM信号（也可使用select实现）&lt;/p&gt;

&lt;p&gt;用alarym秒级实现　connect设置超时代码示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//信号处理函数staticvoidconnect_alarm(intsigno)
{

debug_printf(“SignalHandler”);

return;

}

//alarm超时连接实现

staticvoidconn_alarm()

{

Sigfunc*sigfunc;//现有信号处理函数

sigfunc=signal(SIGALRM,connect_alarm);//建立信号处理函数connect_alarm,(如果有)保存现有的信号处理函数

inttimeout=5;

//设置闹钟

if(alarm(timeout)!=0){

//…闹钟已经设置处理

}

//进行连接操作

if(connect(m_Socket,(structsockaddr*)&amp;amp;addr,sizeof(addr))&amp;lt;0){

if(errno==EINTR){//如果错误号设置为EINTR，说明超时中断了

debug_printf(“Timeout”);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 15 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/15/PHP%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/15/PHP%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/</guid>
        
        <category>Francis 杂谈</category>
        
        <category>PHP</category>
        
        <category>C</category>
        
        
      </item>
    
      <item>
        <title>忙忙碌碌，虚虚实实的生活</title>
        <description>&lt;p&gt;最近太忙碌了，工作忙，学习忙，以后的三年没有周末了。现在的周末比平时都要忙，仿佛一夜之间恢复到了学生时代，在我还没有做好迎接它的时候。&lt;/p&gt;

&lt;p&gt;现在才发现时间真的是太珍贵了，虚度光阴的日子不能再重复了。也好，让自己的生活更充实一些。&lt;/p&gt;

&lt;p&gt;如果简单点想的话，其实没有那么可怕，相信自己会逐步适应这种节奏。&lt;/p&gt;

&lt;p&gt;数学中有种思想叫化归，更适合作为我现在的指导思想。&lt;/p&gt;

&lt;p&gt;来，听首我最喜欢的钢琴曲吧。继续前行！&lt;/p&gt;

&lt;audio controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&gt;
  &lt;source src=&quot;http://source.francissoung.com/music%2FPure%20Music%20-%20%E5%8D%A1%E5%86%9C.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;
Your browser does not support the audio tag.
&lt;/audio&gt;

</description>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/14/%E5%BF%99%E5%BF%99%E7%A2%8C%E7%A2%8C-%E8%99%9A%E8%99%9A%E5%AE%9E%E5%AE%9E%E7%9A%84%E7%94%9F%E6%B4%BB/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/14/%E5%BF%99%E5%BF%99%E7%A2%8C%E7%A2%8C-%E8%99%9A%E8%99%9A%E5%AE%9E%E5%AE%9E%E7%9A%84%E7%94%9F%E6%B4%BB/</guid>
        
        <category>Francis 简单生活</category>
        
        
      </item>
    
      <item>
        <title>不要为自己选择的道路而后悔</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;自己选择的路，再艰难也要走下去，不要为自己选择的道路而后悔，摔跤了不要哭，再爬起来，站直一笑，拍拍尘灰继续奔跑!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;永远都不要去为自己选择的道路而后悔，不管是十年前还是现在&lt;/strong&gt;。控制好心情生活才会处处祥和。好心态塑造好心情，好心情塑造最出色的自己。过去的别再遗憾;未来的无须忧虑;现在的加倍珍惜。摔跤了不要哭，再爬起来，站直一笑，拍拍尘灰继续奔跑。正视人生的每一个挫折适应人生的每一回起伏，吸取人生的每一场失败利用人生的每一个坎坷。&lt;/p&gt;

&lt;p&gt;等待太久得来的东西多半已经不是当初自己想要的样子了。我们都在时光里跌跌撞撞地成长然后一点点离开最初的模样。所谓的朋友就是在你浑身的缺点里，也能看到所剩的优点，然后一捧土一捧土地把你从绝望无助肮脏复杂里拉出来。告诉你，你很好，你值得被人爱。但也会拍拍你的肩膀，你要注意脚下的坑，若绕过就不会摔得鼻青脸肿。&lt;/p&gt;

&lt;p&gt;不要由于别人不能成为你所希望的人而愤怒，因为你自己也不能成为自己所希望的人。总是活在一些极致的情绪里，某一段时间会对生活充满了信心，但突然在某一瞬间，你又会全盘推翻。你有信心时，无所不能，而你推翻这一切的时候，也是百分之百的灰心。&lt;/p&gt;

&lt;p&gt;有时候，最难放下的是一些你从没真正拥有过的事。有时候你把什么放下了，不是因为突然就舍得了，而是因为期限到了，任性够了成熟多了，也就知道这一页该翻过去了。失败时有人伸出一只手来为你擦泪，会好过成功时无数人伸手为你鼓掌。&lt;/p&gt;

&lt;p&gt;有些事，会让你用眼泪哭。有些事，会让你埋在心底里哭。有些事，会让你整个灵魂哭。我们每一个人，都会遇见绝望和痛苦，所有人都会哭，而流泪往往不是最伤心的。你可能心丧若死，却面无表情，枯坐了几天，才突然哭出来，泪水流下时，你才是得救了。眼泪是心里的毒，流出来就好了。&lt;/p&gt;

&lt;p&gt;接下来的日子里，我要做的只有一件事，把自己变得优秀。努力给自己一个最美好的心情，平衡住自己的气息，调整好自己的心态，不急于成功之事，就算摔了再大的跤，也一样能成为明天的更好。学着看淡一些事情，才是对自己最好的保护。&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/14/%E4%B8%8D%E8%A6%81%E4%B8%BA%E8%87%AA%E5%B7%B1%E9%80%89%E6%8B%A9%E7%9A%84%E9%81%93%E8%B7%AF%E8%80%8C%E5%90%8E%E6%82%94/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/14/%E4%B8%8D%E8%A6%81%E4%B8%BA%E8%87%AA%E5%B7%B1%E9%80%89%E6%8B%A9%E7%9A%84%E9%81%93%E8%B7%AF%E8%80%8C%E5%90%8E%E6%82%94/</guid>
        
        <category>Francis 简单生活</category>
        
        
      </item>
    
      <item>
        <title>国内常用公共DNS服务器、各省运营商DNS服务器汇总</title>
        <description>&lt;p&gt;不知道大家有没有过网络是正常的，QQ可以正常登录、游戏也可以正常玩，但是网页无论如何都打不开。这就是电脑网络设置的DNS服务器有问题，不是其故障就是不工作了。&lt;/p&gt;

&lt;p&gt;换了DNS服务器成功解决问题。下边给大家分享一下国内比较大型大众常用的公共DNS服务器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;公共DNS服务器，即系统默认的DNS解析服务器。DNS全称Domain Name System，即域名解析系统。DNS帮助用户在互联网上寻找路径。在互联网上的每一个计算机都拥有一个唯一的地址，称作“IP地址”（即互联网协议地址）。
由于IP地址（为一串数字）不方便记忆，DNS允许用户使用一串常见的字母（即“域名”）取代。
公共DNS服务器，具有无广告、可以在一定程度上防止DNS劫持、不需因上网环境的改变而改变等优势，但是，使用公共DNS也可能存在系统响应慢、被劫持、隐私问题等风险。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://source.francissoung.com/2016%2F03%2F14%2F%E5%9B%BD%E5%86%85%E5%B8%B8%E7%94%A8%E5%85%AC%E5%85%B1DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E5%90%84%E7%9C%81%E8%BF%90%E8%90%A5%E5%95%86DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B1%87%E6%80%BB1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里要说一下，更换或者使用DNS服务器只能做到可以打开浏览网页，不能扶墙，博主居然还看到有极少数提供商号称支持番羽土番。&lt;/p&gt;

&lt;p&gt;虽然公共DNS有一定防DNS劫持作用，但是随着“墙”的升级，这种作用已经很微弱了——无论你是使用ISP的默认DNS，还是使用国外的公共DNS服务器，解析诸如twitter.com之类的域名所得到的结果均会受到DNS污染。&lt;/p&gt;

&lt;p&gt;114 DNS（http://www.114dns.com/），这应该是用户数量数一数二的公共DNS了，档主自己也在使用，推荐。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;114.114.114.114&lt;/p&gt;

  &lt;p&gt;114.114.115.115&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;阿里 AliDNS（http://www.alidns.com/），来自阿里巴巴和马云旗下的公共DNS，还没有体验过，有兴趣可以试试。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;223.5.5.5&lt;/p&gt;

  &lt;p&gt;223.6.6.6&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CNNIC SDNS（http://www.sdns.cn/），来自天朝官方CNNIC的公共DNS，没使用过也没敢用……&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.2.4.8&lt;/p&gt;

  &lt;p&gt;210.2.4.8&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;oneDNS（http://www.onedns.net/），2013年才新推出的一个公共DNS服务器，官网介绍由恶意网站实验室创立，没用过。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;112.124.47.27&lt;/p&gt;

  &lt;p&gt;114.215.126.16&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google DNS（https://developers.google.com/speed/public-dns/），曾经最火最热的一款公共DNS服务器，但是随着Google在中国的没落和国内官方的限制，已经不是太好用了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;8.8.8.8&lt;/p&gt;

  &lt;p&gt;8.8.4.4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;OpenDNS（https://www.opendns.com/），和Google DNS 一样，来自于国外服务商提供的公共DNS，据说同样在国内水土不服。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;208.67.222.222&lt;/p&gt;

  &lt;p&gt;208.67.220.220&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;以下是全国各地电信 DNS 服务器 IP 地址&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;安徽电信 DNS

61.132.163.68
202.102.213.68

北京电信 DNS

219.141.136.10
219.141.140.10

重庆电信 DNS

61.128.192.68
61.128.128.68

福建电信 DNS

218.85.152.99
218.85.157.99

甘肃电信 DNS

202.100.64.68
61.178.0.93

广东电信 DNS

202.96.128.86
202.96.128.166
202.96.134.33
202.96.128.68

广西电信 DNS

202.103.225.68
202.103.224.68

贵州电信 DNS

202.98.192.67
202.98.198.167

河南电信 DNS

222.88.88.88
222.85.85.85

黑龙江电信 DNS

219.147.198.230
219.147.198.242

湖北电信 DNS

202.103.24.68
202.103.0.68

湖南电信 DNS

222.246.129.80
59.51.78.211

江苏电信 DNS

218.2.2.2
218.4.4.4
61.147.37.1
218.2.135.1

江西电信 DNS

202.101.224.69
202.101.226.68

内蒙古电信

219.148.162.31
222.74.39.50

山东电信 DNS

219.146.0.130
219.150.32.132

陕西电信 DNS

218.30.19.40
61.134.1.4

上海电信 DNS

202.96.209.133
116.228.111.118
202.96.209.5
108.168.255.118

四川电信 DNS

61.139.2.69
218.6.200.139

天津电信 DNS

219.150.32.132
219.146.0.132

云南电信 DNS

222.172.200.68
61.166.150.123

浙江电信 DNS

202.101.172.35
61.153.177.196
61.153.81.75
60.191.244.5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以下为全国各地联通 DNS 服务器 IP 地址&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;北京联通 DNS

202.106.196.115
202.106.46.151
202.106.0.20
202.106.195.68

重庆联通 DNS

221.5.203.98
221.7.92.98

广东联通 DNS

210.21.196.6
221.5.88.88

河北联通 DNS

202.99.160.68
202.99.166.4

河南联通 DNS

202.102.224.68
202.102.227.68

黑龙江联通

202.97.224.69
202.97.224.68

吉林联通 DNS

202.98.0.68
202.98.5.68

江苏联通 DNS

221.6.4.66
221.6.4.67

内蒙古联通

202.99.224.68
202.99.224.8

山东联通 DNS

202.102.128.68
202.102.152.3
202.102.134.68
202.102.154.3

山西联通 DNS

202.99.192.66
202.99.192.68

陕西联通 DNS

221.11.1.67
221.11.1.68

上海联通 DNS

210.22.70.3
210.22.84.3

四川联通 DNS

119.6.6.6
124.161.87.155

天津联通 DNS

202.99.104.68
202.99.96.68

浙江联通 DNS

221.12.1.227
221.12.33.227
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;http://www.fulidang.com/3036.html&quot;&gt;【技术控】国内常用公共DNS服务器、各省运营商DNS服务器&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/14/%E5%B8%B8%E7%94%A8%E5%85%AC%E5%85%B1DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/14/%E5%B8%B8%E7%94%A8%E5%85%AC%E5%85%B1DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
        
        <category>Francis 杂谈</category>
        
        
      </item>
    
      <item>
        <title>使用Jekyll+GitHub搭建自己的免费静态博客</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;是一个代码托管网站，现在很多开源项目都放在GitHub上。 利用GitHub，可以让全球各地的程序员们一起协作开发。GitHub 提供了一种功能，叫 &lt;a href=&quot;https://help.github.com/categories/20/articles&quot;&gt;GitHub Pages&lt;/a&gt;, 利用这个功能，我 们可以为项目建立网站，当然，这也意味着我们可以通过 GitHub Pages 建立自己的网站。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;是一个简单的，针对博客设计的静态网站生成器。使用 GitHub 和 Jekyll，我们可以打造自己的独立博客，你可以自由地定制网站的风格，并且这 一切都是免费的。&lt;/p&gt;

&lt;p&gt;我在GitHub上建立的&lt;a href=&quot;http://francissoung.github.io&quot; title=&quot;Francis Soung&quot;&gt;博客&lt;/a&gt;及&lt;a href=&quot;https://github.com/FrancisSoung/blog-jekyll-theme/&quot; title=&quot;Francis Soung&quot;&gt;源代码&lt;/a&gt;，可供大家fork.&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&quot;http://huangxuan.me/&quot;&gt;Hux&lt;/a&gt;带来这么漂亮的模板.也向对此模板做出贡献的Developer表示感谢.&lt;/p&gt;

&lt;p&gt;网站截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F09%2Ffrancissounghomepage.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;入门指引&lt;/h3&gt;

&lt;p&gt;GitHub Pages 的 &lt;a href=&quot;http://pages.github.com/&quot;&gt;主页&lt;/a&gt; 提供了一个简单的入门指引，阅读并 操作一下，会有一个直观简单的认识。&lt;/p&gt;

&lt;p&gt;阮一峰前辈的文章《&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&quot;&gt;搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门&lt;/a&gt;》是使用 GitHub 和 Jekyll 搭建独立博客非常好的入门文章，强烈建议先阅读并操作一遍。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;建立自己的博客&lt;/h3&gt;

&lt;p&gt;在学习完阮一峰前辈的文章后，你就已经有能力搭建自己的独立博客了，但是这个博客 只有最基本的功能，并且也不好看。这时候，你面临几个选择:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完全自己定制博客&lt;/li&gt;
  &lt;li&gt;找一份框架，修改后使用&lt;/li&gt;
  &lt;li&gt;从GitHub上fork别人的博客代码，在其中添加自己的文章&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果选择 2, 那么 &lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;jekyll-bootstrap&lt;/a&gt;是一个选择。&lt;/p&gt;

&lt;p&gt;如果选择 3, 那么自己Google一下 github.io 博客 能找到不少博客,去fork,然后修改一下就好。&lt;/p&gt;

&lt;p&gt;如果选择 1, 那么可以好好看看后文的内容。&lt;/p&gt;

&lt;h3 id=&quot;github--jekyll-&quot;&gt;GitHub + Jekyll 工作机制&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;机制一&lt;/h4&gt;

&lt;p&gt;简单地说，你在 GitHub 上有一个账号，名为username(任意)， 有一个项目，名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io&lt;/code&gt;(固定格式，username与账号名一致)， 项目分支名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;(固定)，这个分支有着类似下面的 目录结构:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── index.html
├── _config.yml
├── assets
│   ├── blog-images
│   ├── css
│   ├── fonts
│   ├── images
│   └── javascripts
├── _includes
├── _layouts
├── _plugins
├── _posts
└── _site
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，当你访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://username.github.io/&lt;/code&gt;时，GitHub 会使用 Jekyll 解析 用户 username名下的username.github.io项目中，分支为master 的源代码，为你构建一个静态网站，并将生成的 index.html 展示给你。&lt;/p&gt;

&lt;p&gt;关于这个目录更多的内容，我们还不需要关心，如果你好奇心比较重，可以先看后文源代码一节。&lt;/p&gt;

&lt;p&gt;看完上面的解释，你可能会有一些疑问，因为按照上面的说法，一个用户只能有一个网站，那我有很多项目，每个项目都需要一个项目网站，该怎么办呢？另外，在阮一峰前辈的文章中，特别提到，分支名应该为 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt;，这又是怎么回事呢？&lt;/p&gt;

&lt;p&gt;原来，GitHub认为，一个GitHub账号对应一个用户或者一个组织，GitHub会 给这个用户分配一个域名：&lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io&lt;/code&gt;，当用户访问这个域名时， GitHub会去解析username用户下，&lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io&lt;/code&gt;项目的master分支， 这与我们之前的描述一致。&lt;/p&gt;

&lt;p&gt;另外，GitHub还为每个项目提供了域名，例如，你有一个项目名为blog， GitHub为这个项目提供的域名为&lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io/blog&lt;/code&gt;， 当你访问这个域名时，GitHub会去解析username用户下，blog项目的gh-pages 分支。&lt;/p&gt;

&lt;p&gt;所以，要搭建自己的博客，你可以选择建立名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io&lt;/code&gt;的项目， 在&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支下存放网站源代码，也可以选择建立名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;blog&lt;/code&gt; 的项目，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt;分支下存放网站源代码。&lt;/p&gt;

&lt;p&gt;GitHub 的 Help 文档中的 &lt;a href=&quot;https://help.github.com/articles/user-organization-and-project-pages&quot;&gt;User, Organization and Project Pages&lt;/a&gt;对此有 详细的描述。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;机制二&lt;/h4&gt;

&lt;p&gt;Jekyll 提供了插件功能，在网站源代码目录下，有一个名为 _plugins的目录，你可以将一些插件放进去，这样，Jekyll在解析网站源代码时，就会运行你的插件，这样插件是 Ruby 写成的。可以为Jekyll添加功能，例如，Jekyll默认是不提供分类页面的，你可以写一个插件，根据文章内容生成分类页面。如果没有插件，你只能每次写文章添加分类时为每个分类手动写HTML页面。&lt;/p&gt;

&lt;p&gt;在本地运行 Jekyll 时，这些插件会自动被调用，但是GitHub在解析网站源代码时，出于安全考虑，会开启安全模式，禁用这些插件。我们既想用这些插件，又想用 GitHub，怎么办呢怎么办呢？&lt;/p&gt;

&lt;p&gt;GitHub还为我们提供了更一种解析网站的方式，那就是直接上传最终的静态网页，这样，我们可以在本地使用 Jeklly 把网站解析出来，然后再上传到 GitHub上， 这就使得我们既使用了插件，又使用了 GitHub。在上文的目录结构中，有一个 名为 _site 的目录，这个就是Jeklly在本地解析时最终生成的静态网站，我们把其中的内容上传到 GitHub 的项目中就可以了。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;工作流&lt;/h3&gt;

&lt;p&gt;关于 git 和 jekyll 的安装与基本使用，这里就不多说了。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;工作流一&lt;/h4&gt;

&lt;p&gt;如果你不使用插件，那么只需要维护一个分支就好:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- username/username.github.io 的 master 分支
- username/blog 的 gh-pages 分支
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 username 是你的 GitHub 帐号。&lt;/p&gt;

&lt;p&gt;你需要在本地维护一份网站源代码，添加新文章后，使用 jekyll 在本地测试一下，没有问题后，commit 到 GitHub 上的相应分支中就可以了。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;工作流二&lt;/h4&gt;

&lt;p&gt;如果你需要使用插件，那么需要维护两个分支，一个是网站的源代码分支，另一个 是 Jeklly 解析源代码后生成的静态网站。&lt;/p&gt;

&lt;p&gt;例如，我的源代码分支名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;，静态网站分支名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt;。平时写博客时， 首先在 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支下，添加新文章，然后本地使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt; 将添加文章后的网站 解析一次，这时 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 目录下就有新网站的静态代码了。然后把这个目录下的所有内容 复制到 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt; 分支下。这个过程，可以写一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;，每次添加文章后 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 一下， 就自动将文章发布到 GitHub 上。&lt;/p&gt;

&lt;p&gt;Makefile 内容如下：&lt;/p&gt;

&lt;p&gt;deploy:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout master
git add -A
git commit -m &quot;deploy blog&quot;
cp -r _site/ /tmp/
git checkout gh-pages
rm -r ./*
cp -r /tmp/_site/* ./
git add -A
git commit -m &quot;deploy blog&quot;
git push origin gh-pages
git checkout master
echo &quot;deploy succeed&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面的内容涉及源代码，如果需要进一步学习，或者有问题，可以在 &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jeklly&lt;/a&gt; 官网上找到更详细的解释，或者在评论中留言。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;源代码&lt;/h3&gt;

&lt;p&gt;再来看一下这个目录结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── _config.yml
├── index.html
├── assets
│   ├── blog-images
│   ├── css
│   ├── fonts
│   ├── images
│   └── javascripts
├── _includes
├── _layouts
├── _plugins
├── _posts
└── _site
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;configyml&quot;&gt;_config.yml&lt;/h4&gt;

&lt;p&gt;这是针对 Jekyll 的&lt;a href=&quot;http://jekyllrb.com/docs/configuration/&quot;&gt;配置文件&lt;/a&gt;， 决定了 Jekyll 如何解析网站的源代码,下面是一个示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;baseurl: /StrayBirds
markdown: redcarpet
safe: false
pygments: true
excerpt_separator: &quot;\n\n\n&quot;
paginate: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我的网站建立在 StrayBirds 项目中，所以 baseurl 设置成 StrayBirds， 我的文章采用 Markdown 格式写成，可以指定 Markdown 的解析器 redcarpet。 另外，安全模式需要关闭，以便 Jekyll 解析时会运行插件。 pygments 可以使得Jekyll解析文章中源代码时加入特殊标记，例如指定代码类型， 这可以被很多 javascript 代码高度库使用。 excerpt_separator 指定了一个摘要分割符号，这样 Jekyll 可以在解析文章时， 将文章的提要提取出来。 paginate 指定了一页有几篇文章，页数太多时，我们可以将文章列表分页，我们在 后文还会提到。&lt;/p&gt;

&lt;h4 id=&quot;layouts&quot;&gt;_layouts&lt;/h4&gt;

&lt;p&gt;这个目录存放着一些网页模板文件，为网站所有网页提供一个基本模板，这样 每个网页只需要关心自己的内容就好，其它的都由模板决定。例如，这个目录下的 default.html 文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;{{ page.title }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;header&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/header&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;aside&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/aside&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;article&amp;gt;&lt;/span&gt;
{{ content }}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/article&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;footer&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/footer&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出，这个文件就是所有页面共有的东西，每个页面的具体内容会被填充在&lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;中，注意这个&lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;两边的标记，这是一种叫&lt;code class=&quot;highlighter-rouge&quot;&gt;liquid&lt;/code&gt;的标记语言。 另外，还有那个&lt;code class=&quot;highlighter-rouge&quot;&gt;page.title&lt;/code&gt;，其中 page 表示引用 default.html的 那个页面，这个页面的 title 值会在 page 相应页面中被设置，例如 下面的 index.html 文件，开头部分就设置了 title值。&lt;/p&gt;

&lt;h4 id=&quot;indexhtml&quot;&gt;index.html&lt;/h4&gt;

&lt;p&gt;这是网站的首页，访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://username.github.io&lt;/code&gt; 时，会指向 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://username.github.io/index.html&lt;/code&gt;，我们看一下基本内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: default
title: 首页
---


&amp;lt;ul class=&quot;post-list&quot;&amp;gt;
    {% for post in site.posts %}
        &amp;lt;a href=&quot;{{site.baseurl}}{{post.url}}&quot;&amp;gt; {{ post.title }}  &amp;lt;/a&amp;gt; &amp;lt;br&amp;gt;
        {{ post.date | date: &quot;%F&quot; }} &amp;lt;br&amp;gt;
        {{ post.category }} &amp;lt;br&amp;gt;
        {{ post.excerpt }} 
    {% endfor %}

&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意，文件开头的描述，我们称之为 &lt;a href=&quot;http://jekyllrb.com/docs/frontmatter/&quot;&gt;front-matter&lt;/a&gt;， 是对当前文件的一种描述，这里 设置的变量可以在解析时被引用，例如这里的 layout就会告诉 Jekyll, 生成 index.html 文件时，去 _layouts 目录下找 default.html 文件，然后把当前文件解析后，添加到 default.html 的 content 部分，组成最终的 index.html 文件。还有title 设置好的 值，会在 default.html 中通过 page.title 被引用。&lt;/p&gt;

&lt;p&gt;文件的主体部分遍历了站点的所有文章，并将他们显示出来，这些语法都是 liquid 语法， 其中的变量，例如 site, 由 Jekyll 设置我们只需要引用就可以了。而 post 中的变量， 如 post.title, post.category 是由 post 文件中的 front-matter 决定，后面马上就会看到。&lt;/p&gt;

&lt;h4 id=&quot;posts&quot;&gt;_posts&lt;/h4&gt;

&lt;p&gt;这个目录存放我们的所有博客文章，他们的名字有统一的格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YEAR-MONTH-DAY-title.markdown
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如，2014-02-15-github-jeklly.markdown，这个文件名会被解析，前面的 index.html 中， post.date 的值就由这里文件名中的日期而来。下面，我们看看一篇文章的内容示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: default
title: 使用 Markdown
category: 工具
comments: true
---
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;为什么使用 Markdown&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;看上去不错&lt;/li&gt;
  &lt;li&gt;既然看上去不错，为什么不试试呢&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如何使用 Markdown&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以看出，文章的 front-matter 部分设置了多项值，以后可以通过类似 &lt;code class=&quot;highlighter-rouge&quot;&gt;post.title, post.category&lt;/code&gt; 的方式引用这些些，另外，layout部分的值和之前解释的一样， 文件的内容会被填充到 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts/default.html&lt;/code&gt; 文件的 &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt; 变量中。&lt;/p&gt;

&lt;p&gt;另外，文章中 为什么不试试呢之后的有三个不可见的 \n，它决定了这三个 \n 之前的内容会被放在 post.excerpt 变量中，供其它文件使用。&lt;/p&gt;

&lt;h4 id=&quot;includes&quot;&gt;_includes&lt;/h4&gt;

&lt;p&gt;这个文件中，存放着一些模块文件，例如 categories.ext，其它文件可以通过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;categories.ext&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;来引用这个文件的内容，方便代码模块化和重用。&lt;/p&gt;

&lt;h4 id=&quot;plugins&quot;&gt;_plugins&lt;/h4&gt;

&lt;p&gt;这个文件中存放一些Ruby插件, 例如 gen_categories.rb，这些文件会在 Jekyll 解析网站源代码时被执行。下一节讲述的就是插件。&lt;/p&gt;

&lt;h4 id=&quot;site&quot;&gt;_site&lt;/h4&gt;

&lt;p&gt;Jekyll 解析整个网站源代码后，会将最终的静态网站源代码放在这里。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;插件&lt;/h3&gt;

&lt;p&gt;插件使用 Ruby 写成，放在 _plugins 目录下，有些 Jekyll 没有的功能，又不能 手动添加，因为页面的内容会随着文章日期类别的不同而不同，例如分类功能和归档功能， 这时，就需要使用插件自动生成一些页面和目录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分类插件推荐使用 &lt;a href=&quot;https://github.com/shigeya/jekyll-category-archive-plugin/tree/master/_plugins&quot;&gt;jekyll-category-archive-plugin&lt;/a&gt;, 它会根据网站文章的分类信息，为每个类别生成一个页面。&lt;/p&gt;

&lt;p&gt;使用方法是，把 &lt;code class=&quot;highlighter-rouge&quot;&gt;plugins/categoryarchive_plugin.rb&lt;/code&gt; 放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;plugins&lt;/code&gt; 目录下， 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts/categoryarchive.html&lt;/code&gt; 放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;layouts&lt;/code&gt; 目录下， 这样，这个插件会在Jekyll解析网站时，生成相应categories目录，目录下是各个分类， 每个分类下都有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 文件，这个文件是根据模板文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;categoryarchive.html&lt;/code&gt; 生成的，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_site/categories/
├── 工具
│   └── index.html
├── 思想
│   └── index.html
├── 技术
│   └── index.html
└── 源代码阅读
    └── index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，你就可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://username.github.io/blog/categories/工具/&lt;/code&gt; 访问 工具类下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;归档&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;归档插件推荐使用 &lt;a href=&quot;https://github.com/shigeya/jekyll-monthly-archive-plugin&quot;&gt;jekyll-monthly-archive-plugin&lt;/a&gt;,它会根据网站 _posts目录下的文章日期，为每个月生成一个页面。&lt;/p&gt;

&lt;p&gt;使用方法同上。注意，这个插件在 jekyll-1.4.2 中可能会出错，在 jekyll-1.2.0 中没有错误。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;组件&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;分页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当文章很多时，就需要使用分页功能，在 Jekyll 官网上提供了一种 &lt;a href=&quot;http://jekyllrb.com/docs/pagination/&quot;&gt;实现&lt;/a&gt;，把相应代码放在 主页上，然后在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; 中设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;paginate&lt;/code&gt; 值就行了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;评论&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;评论功能需要使用社会化评论系统，我使用的是 &lt;a href=&quot;http://disqus.com/&quot;&gt;DISQUS&lt;/a&gt;, 注册 之后，将评论区的一段代码放在你需要使用评论功能的页面上, 然后，通过在页面的 front-matter 部分使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;comments: true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启用评论。&lt;/p&gt;

&lt;p&gt;评论区截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F09%2Fdisqus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;自定义域名解析&lt;/h3&gt;

&lt;p&gt;这里很简单了，在你的网站根目录中新建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;CNAME&lt;/code&gt;的文件，&lt;strong&gt;注：一定要大写&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F09%2FCNAME.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在CNAME文件中添加你要解析的域名。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F09%2FCNAME1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;获取GitHub Page的IP地址，最好的方法就是ping一下你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io&lt;/code&gt; 域名。&lt;/p&gt;

&lt;p&gt;最后在你的域名提供商域名管理系统中添加对应的解析。我这里做了一个CNAME，可直接解析到A记录到IP即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F09%2FCNAME3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基本的内容就介绍到这里，任何问题，欢迎留言。&lt;/p&gt;

</description>
        <pubDate>Wed, 09 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/09/%E4%BD%BF%E7%94%A8Jekyll+GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/09/%E4%BD%BF%E7%94%A8Jekyll+GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</guid>
        
        <category>GitHub</category>
        
        <category>Francis 杂谈</category>
        
        
      </item>
    
      <item>
        <title>nginx.conf配置文件详解</title>
        <description>&lt;p&gt;Nginx配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置），每部分包含若干个指令。main部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。&lt;/p&gt;

&lt;p&gt;当前nginx支持的几个指令上下文：&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;通用&lt;/h3&gt;

&lt;p&gt;下面的nginx.conf简单的实现nginx在前端做反向代理服务器的例子，处理js、png等静态文件，jsp等动态请求转发到其它服务器tomcat：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user  www www;
worker_processes  2;
error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
pid        logs/nginx.pid;
events {
    use epoll;
    worker_connections  2048;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
    #access_log  logs/access.log  main;
    sendfile        on;
    # tcp_nopush     on;
    keepalive_timeout  65;
  # gzip压缩功能设置
    gzip on;
    gzip_min_length 1k;
    gzip_buffers    4 16k;
    gzip_http_version 1.0;
    gzip_comp_level 6;
    gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;
    gzip_vary on;
  
  # http_proxy 设置
    client_max_body_size   10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   75;
    proxy_send_timeout   75;
    proxy_read_timeout   75;
    proxy_buffer_size   4k;
    proxy_buffers   4 32k;
    proxy_busy_buffers_size   64k;
    proxy_temp_file_write_size  64k;
    proxy_temp_path   /usr/local/nginx/proxy_temp 1 2;
  # 设定负载均衡后台服务器列表 
    upstream  backend  { 
              #ip_hash; 
              server   192.168.10.100:8080 max_fails=2 fail_timeout=30s ;  
              server   192.168.10.101:8080 max_fails=2 fail_timeout=30s ;  
    }
  # 很重要的虚拟主机配置
    server {
        listen       80;
        server_name  itoatest.example.com;
        root   /apps/oaapp;
        charset utf-8;
        access_log  logs/host.access.log  main;
        #对 / 所有做负载均衡+反向代理
        location / {
            root   /apps/oaapp;
            index  index.jsp index.html index.htm;
            proxy_pass        http://backend;  
            proxy_redirect off;
            # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
            proxy_set_header  Host  $host;
            proxy_set_header  X-Real-IP  $remote_addr;  
            proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
            
        }
        #静态文件，nginx自己处理，不去backend请求tomcat
        location  ~* /download/ {  
            root /apps/oa/fs;  
            
        }
        location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$   
        {   
            root /apps/oaapp;   
            expires      7d; 
        }
       	location /nginx_status {
            stub_status on;
            access_log off;
            allow 192.168.10.0/24;
            deny all;
        }
        location ~ ^/(WEB-INF)/ {   
            deny all;   
        }
        #error_page  404              /404.html;
        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
  ## 其它虚拟主机，server 指令开始
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;### 常用指令说明&lt;/p&gt;

&lt;h4 id=&quot;main&quot;&gt;main全局配置&lt;/h4&gt;

&lt;p&gt;nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;woker_processes 2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在配置文件的顶级main部分，worker角色的工作进程的个数，master进程是接收并分配请求给worker处理。这个数值简单一点可以设置为cpu的核数&lt;code class=&quot;highlighter-rouge&quot;&gt;grep ^processor /proc/cpuinfo | wc -l&lt;/code&gt;，也是 auto 值，如果开启了ssl和gzip更应该设置成与逻辑CPU数量一样甚至为2倍，可以减少I/O操作。如果nginx服务器还有其它服务，可以考虑适当减少。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;worker_cpu_affinity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也是写在main部分。在高并发情况下，通过设置cpu粘性来降低由于多CPU核切换造成的寄存器等现场重建带来的性能损耗。如worker_cpu_affinity 0001 0010 0100 1000; （四核）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;worker_connections 2048&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;写在events部分。每一个worker进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。nginx作为反向代理服务器，计算公式 最大连接数 = worker_processes * worker_connections/4，所以这里客户端最大连接数是1024，这个可以增到到8192都没关系，看情况而定，但不能超过后面的worker_rlimit_nofile。当nginx作为http服务器时，计算公式里面是除以2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;worker_rlimit_nofile 10240&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;写在main部分。默认是没有设置，可以限制为操作系统最大的限制65535。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;use epoll&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;写在events部分。在Linux操作系统下，nginx默认使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。在操作系统不支持这些高效模型时才使用select。&lt;/p&gt;

&lt;h4 id=&quot;http&quot;&gt;http服务器&lt;/h4&gt;

&lt;p&gt;与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sendfile on&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;keepalive_timeout 65&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;长连接超时时间，单位是秒，这个参数很敏感，涉及浏览器的种类、后端服务器的超时设置、操作系统的设置，可以另外起一片文章了。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s内没上传完成会导致失败。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;send_timeout&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx将会关闭连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;client_max_body_size 10m&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;client_body_buffer_size 128k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缓冲区代理缓冲用户端请求的最大字节数&lt;/p&gt;

&lt;h4 id=&quot;httpproxy&quot;&gt;模块http_proxy&lt;/h4&gt;

&lt;p&gt;这个模块实现的是nginx作为反向代理服务器的功能，包括缓存功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_connect_timeout 60&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nginx跟后端服务器连接超时时间(代理连接超时)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_read_timeout 60&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_buffer_size 4k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置代理服务器（nginx）从后端realserver读取并保存用户头信息的缓冲区大小，默认与proxy_buffers大小相同，其实可以将这个指令值设的小一点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_buffers 4 32k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;proxy_buffers缓冲区，nginx针对单个连接缓存来自后端realserver的响应，网页平均在32k以下的话，这样设置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_busy_buffers_size 64k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;高负荷下缓冲大小（proxy_buffers*2）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_max_temp_file_size&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当 proxy_buffers 放不下后端服务器的响应内容时，会将一部分保存到硬盘的临时文件中，这个值用来设置最大临时文件大小，默认1024M，它与 proxy_cache 没有关系。大于这个值，将从upstream服务器传回。设置为0禁用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_temp_file_write_size 64k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。proxy_temp_path（可以在编译的时候）指定写到哪那个目录。&lt;/p&gt;

&lt;p&gt;proxy_pass，proxy_redirect见 location 部分。&lt;/p&gt;

&lt;h4 id=&quot;httpgzip&quot;&gt;模块http_gzip&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;gzip on&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开启gzip压缩输出，减少网络传输。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_min_length 1k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是20。建议设置成大于1k的字节数，小于1k可能会越压越大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_buffers 4 16k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_http_version 1.0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于识别 http 协议的版本，早期的浏览器不支持 Gzip 压缩，用户就会看到乱码，所以为了支持前期版本加上了这个选项，如果你用了 Nginx 的反向代理并期望也启用 Gzip 压缩的话，由于末端通信是 http/1.0，故请设置为 1.0。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_comp_level 6&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_types&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_proxied any&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nginx作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，匹配的前提是后端服务器必须要返回包含”Via”的 header头。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_vary on&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和http头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过gzip压缩的页面，例如，用Squid缓存经过Nginx压缩的数据。。&lt;/p&gt;

&lt;h3 id=&quot;server&quot;&gt;server虚拟主机&lt;/h3&gt;

&lt;p&gt;http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server。每个server通过监听地址或端口来区分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;listen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;监听端口，默认80，小于1024的要以root启动。可以为&lt;code class=&quot;highlighter-rouge&quot;&gt;listen *:80&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;listen 127.0.0.1:80&lt;/code&gt;等形式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;server_name&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务器名，如&lt;code class=&quot;highlighter-rouge&quot;&gt;localhost、www.example.com&lt;/code&gt;，可以通过正则匹配。&lt;/p&gt;

&lt;h4 id=&quot;httpstream&quot;&gt;模块http_stream&lt;/h4&gt;

&lt;p&gt;这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡，upstream后接负载均衡器的名字，后端realserver以&lt;code class=&quot;highlighter-rouge&quot;&gt;host:port options&lt;/code&gt;; 方式组织在 {} 中。如果后端被代理的只有一台，也可以直接写在 proxy_pass 。&lt;/p&gt;

&lt;h3 id=&quot;location&quot;&gt;location&lt;/h3&gt;

&lt;p&gt;http服务中，某些特定的URL对应的一系列配置项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;root /var/www/html&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义服务器的默认网站根目录位置。如果locationURL匹配的是子目录或文件，root没什么作用，一般放在server指令里面或/下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index index.jsp index.html index.htm&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义路径下默认访问的文件名，一般跟着root放&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_pass http:/backend&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;请求转向backend定义的服务器列表，即反向代理，对应upstream负载均衡器。也可以&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_pass http://ip:port&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proxy_redirect off;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;其它&lt;/h3&gt;

&lt;h4 id=&quot;allowdeny&quot;&gt;访问控制 allow/deny&lt;/h4&gt;

&lt;p&gt;Nginx 的访问控制模块默认就会安装，而且写法也非常简单，可以分别有多个allow,deny，允许或禁止某个ip或ip段访问，依次满足任何一个规则就停止往下匹配。如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location /nginx-status {
  stub_status on;
  access_log off;
#  auth_basic   &quot;NginxStatus&quot;;
#  auth_basic_user_file   /usr/local/nginx-1.6/htpasswd;
  allow 192.168.10.100;
  allow 172.29.73.0/24;
  deny all;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们也常用 httpd-devel 工具的 htpasswd 来为访问的路径设置登录密码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# htpasswd -c htpasswd admin
New passwd:
Re-type new password:
Adding password for user admin
# htpasswd htpasswd admin    //修改admin密码
# htpasswd htpasswd sean    //多添加一个认证用户
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就生成了默认使用CRYPT加密的密码文件。打开上面nginx-status的两行注释，重启nginx生效。&lt;/p&gt;

&lt;h4 id=&quot;autoindex&quot;&gt;列出目录 autoindex&lt;/h4&gt;

&lt;p&gt;Nginx默认是不允许列出整个目录的。如需此功能，打开nginx.conf文件，在location，server 或 http段中加入&lt;code class=&quot;highlighter-rouge&quot;&gt;autoindex on&lt;/code&gt;;，另外两个参数最好也加上去:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;autoindex_exact_size off&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认为on，显示出文件的确切大小，单位是bytes。改为off后，显示出文件的大概大小，单位是kB或者MB或者GB&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;autoindex_localtime on&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认为off，显示的文件时间为GMT时间。改为on后，显示的文件时间为文件的服务器时间&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location /images {
  root   /var/www/nginx-default/images;
  autoindex on;
  autoindex_exact_size off;
  autoindex_localtime on;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 07 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/07/nginx.conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/07/nginx.conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>Nginx</category>
        
        <category>Linux</category>
        
        
      </item>
    
  </channel>
</rss>
