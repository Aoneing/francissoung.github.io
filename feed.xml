<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Francis Soung</title>
    <description>这是一个程序员的日记薄，记录工作与生活的点点滴滴。包括WEB程序开发、Linux服务器管理、LAMP/LNMP环境配置优化、PHP网络技术、MySQL优化等技术分享以及个人生活旅行中的所见所闻所解。</description>
    <link>http://www.francissoung.com/</link>
    <atom:link href="http://www.francissoung.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 18 Mar 2016 14:21:58 +0800</pubDate>
    <lastBuildDate>Fri, 18 Mar 2016 14:21:58 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>如何减少接口响应时间</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Premature optimization is the root of all evil.&lt;/p&gt;

  &lt;p&gt;　 — Donald Knuth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于程序优化，我一直采取保守的态度，除非万不得已。但是随着业务的不断发展，程序越来越复杂，代码越写越多，优化似乎是终有一天会到来的事情。&lt;/p&gt;

&lt;p&gt;那么对于一个典型的后台服务接口，我们可以从那些方面入手进行优化呢？&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;接口拆分&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;接口垂直拆分&lt;/h3&gt;

&lt;p&gt;垂直拆分可以简单理解为微服务化，把一个大而复杂的服务拆分成多个相互独立，职能单一的服务，单独部署。 更细粒度拆分的好处是，能对某个具体的微服务进行特殊优化，以最大的投入产出比来解决整个服务的性能。 垂直拆分还有一个好处是，对于非必须的接口，可以很方便的进行降级处理，把坏影响隔离到核心逻辑外部。 最容易想到的优化办法是把某个对整体性能有决定性影响的微服务接口进行水平扩容。&lt;/p&gt;

&lt;p&gt;注意: 拆分后必定会增加外部接口调用，多少会有些额外开销，但是对于有限几个调用，拆分的还是值得的。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;接口水平拆分&lt;/h3&gt;

&lt;p&gt;这里说的水平拆分一定不是把一个接口部署更多份，因为这样只能解决接口的容量问题，但是不能减少接口的响应时间。 水平拆分可以简单理解成mapreduce模型，把整个计算逻辑或者数据平均分配到集群中的N个服务器去，然后由一台机器去并发调用并做结果合并。 理论上这种方式能把响应减少到1/N+合并+调用开销的时间。&lt;/p&gt;

&lt;p&gt;注意： 一个问题需要考虑的是，如果并发调用的接口返回的数据量比较大，可能会对合并机器的网络负载和数据序列化(CPU)有一定影响。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;缓存&lt;/h2&gt;

&lt;h3 id=&quot;section-4&quot;&gt;接口缓存&lt;/h3&gt;

&lt;p&gt;一个有着复杂逻辑或者大量计算数据的接口，能对整个结果进行缓存再好不过了。缓存针对不同的场景会有多种策略，对于有大量并发请求的场景， 推荐一个方案：一种基于“哨兵”的分布式缓存设计，不会有损失第一个用户，也不会有定时更新缓存的额外开销。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;本地缓存&lt;/h3&gt;

&lt;p&gt;本地缓存有两种场景，对于类似字典类型的数据，可以静态化后放入内存，定时去刷新或者采用通知机制去更新。&lt;/p&gt;

&lt;p&gt;还有一种场景是用ThreadLocal缓存重复内部计算与重复的对象创建； 对于链路比较长或者循环比较深的接口，ThreadLocal减少重复计算和对象创建，从而降低RT和节约内存。&lt;/p&gt;

&lt;p&gt;注意： 在有内部并发的地方使用ThreadLocal一定要注意不同线程间的数据同步。主线程的ThreadLocal数据和每个并发子线程的ThreadLocal数据要同步好。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;内部优化&lt;/h2&gt;

&lt;h3 id=&quot;section-7&quot;&gt;非核心流程异步化&lt;/h3&gt;

&lt;p&gt;类似于发消息，写日志，更新缓存等不会影响接口准确性的非核心流程，可以采用异步方式进行处理，不阻塞主计算逻辑处理。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;内部并发&lt;/h3&gt;

&lt;p&gt;如果进行水平拆分后，并发调用IO较大，可以考虑换成内部并发解决IO问题。如果内部并发涉及到每个线程更新同一个集合数据，不用忘了使用线程安全的集合。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;优化一定不是一蹴而就的，整个优化过程是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;统计--&amp;gt;方案--&amp;gt;验证&lt;/code&gt;的闭环，需要不断试错，不断挖掘，最终达到预期。&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/16/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/16/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/</guid>
        
        <category>Francis 杂谈</category>
        
        <category>编程</category>
        
        
      </item>
    
      <item>
        <title>PHP超时处理全面总结</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;在PHP开发中工作里非常多使用到超时处理到超时的场合，我说几个场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;异步获取数据如果某个后端数据源获取不成功则跳过，不影响整个页面展现&lt;/li&gt;
  &lt;li&gt;为了保证Web服务器不会因为当个页面处理性能差而导致无法访问其他页面，则会对某些页面操作设置&lt;/li&gt;
  &lt;li&gt;对于某些上传或者不确定处理时间的场合，则需要对整个流程中所有超时设置为无限，否则任何一个环节设置不当，都会导致莫名执行中断&lt;/li&gt;
  &lt;li&gt;多个后端模块（MySQL、Memcached、HTTP接口），为了防止单个接口性能太差，导致整个前面获取数据太缓慢，影响页面打开速度，引起雪崩&lt;/li&gt;
  &lt;li&gt;。。。很多需要超时的场合&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些地方都需要考虑超时的设定，但是PHP中的超时都是分门别类，各个处理方式和策略都不同，为了系统的描述，我总结了PHP中常用的超时处理的总结。&lt;/p&gt;

&lt;h2 id=&quot;web&quot;&gt;Web服务器超时处理&lt;/h2&gt;

&lt;h3 id=&quot;apache&quot;&gt;Apache&lt;/h3&gt;

&lt;p&gt;一般在性能很高的情况下，缺省所有超时配置都是30秒，但是在上传文件，或者网络速度很慢的情况下，那么可能触发超时操作。&lt;/p&gt;

&lt;p&gt;目前apachefastcgiphp-fpm模式下有三个超时设置：&lt;/p&gt;

&lt;p&gt;fastcgi超时设置：&lt;/p&gt;

&lt;p&gt;修改httpd.conf的fastcgi连接配置，类似如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;IfModulemod_fastcgi.c&amp;gt;FastCgiExternalServer/home/forum/apache/apache_php/cgi-bin/php-cgi-socket/home/forum/php5/etc/php-fpm.sock
ScriptAlias/fcgi-bin/”/home/forum/apache/apache_php/cgi-bin/”

AddHandlerphp-fastcgi.php

Actionphp-fastcgi/fcgi-bin/php-cgi

AddTypeapplication/x-httpd-php.php

&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;缺省配置是30s，如果需要定制自己的配置，需要修改配置，比如修改为100秒：(修改后重启apache)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;IfModulemod_fastcgi.c&amp;gt;
FastCgiExternalServer/home/forum/apache/apache_php/cgi-bin/php-cgi-socket/home/forum/php5/etc/php-fpm.sock-idle-timeout100

ScriptAlias/fcgi-bin/”/home/forum/apache/apache_php/cgi-bin/”

AddHandlerphp-fastcgi.php

Actionphp-fastcgi/fcgi-bin/php-cgi

AddTypeapplication/x-httpd-php.php

&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果超时会返回500错误，断开跟后端php服务的连接，同时记录一条apache错误日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ThuJan2718:30:152011][error][client10.81.41.110]FastCGI:commwithserver”/home/forum/apache/apache_php/cgi-bin/php-cgi”aborted:idletimeout(30sec)

[ThuJan2718:30:152011][error][client10.81.41.110]FastCGI:incompleteheaders(0bytes)receivedfromserver”/home/forum/apache/apache_php/cgi-bin/php-cgi”
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他fastcgi配置参数说明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IdleTimeout发呆时限ProcessLifeTime一个进程的最长生命周期，过期之后无条件kill
MaxProcessCount最大进程个数
DefaultMinClassProcessCount每个程序启动的最小进程个数
DefaultMaxClassProcessCount每个程序启动的最大进程个数
IPCConnectTimeout程序响应超时时间
IPCCommTimeout与程序通讯的最长时间，上面的错误有可能就是这个值设置过小造成的
MaxRequestsPerProcess每个进程最多完成处理个数，达成后自杀
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;lighttpd&quot;&gt;Lighttpd&lt;/h3&gt;

&lt;p&gt;配置：lighttpd.conf&lt;/p&gt;

&lt;p&gt;Lighttpd配置中，关于超时的参数有如下几个（篇幅考虑，只写读超时，写超时参数同理）：&lt;/p&gt;

&lt;p&gt;主要涉及选项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server.max-keep-alive-idle=5
server.max-read-idle=60
server.read-timeout=0
server.max-connection-idle=360

————————————————–

#每次keep-alive的最大请求数,默认值是16

server.max-keep-alive-requests=100

#keep-alive的最长等待时间,单位是秒，默认值是5

server.max-keep-alive-idle=1200

#lighttpd的work子进程数，默认值是0，单进程运行

server.max-worker=2

#限制用户在发送请求的过程中，最大的中间停顿时间(单位是秒)，

#如果用户在发送请求的过程中(没发完请求)，中间停顿的时间太长，lighttpd会主动断开连接

#默认值是60(秒)

server.max-read-idle=1200

#限制用户在接收应答的过程中，最大的中间停顿时间(单位是秒)，

#如果用户在接收应答的过程中(没接完)，中间停顿的时间太长，lighttpd会主动断开连接

#默认值是360(秒)

server.max-write-idle=12000

#读客户端请求的超时限制，单位是秒,配为0表示不作限制

#设置小于max-read-idle时，read-timeout生效

server.read-timeout=0

#写应答页面给客户端的超时限制，单位是秒，配为0表示不作限制

#设置小于max-write-idle时，write-timeout生效

server.write-timeout=0

#请求的处理时间上限，如果用了mod_proxy_core，那就是和后端的交互时间限制,单位是秒

server.max-connection-idle=1200

————————————————–
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;对于一个keep-alive连接上的连续请求，发送第一个请求内容的最大间隔由参数max-read-idle决定，从第二个请求起，发送请求内容的最大间隔由参数max-keep-alive-idle决定。请求间的间隔超时也由max-keep-alive-idle决定。发送请求内容的总时间超时由参数read-timeout决定。Lighttpd与后端交互数据的超时由max-connection-idle决定。&lt;/p&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;http://www.snooda.com/read/244&lt;/p&gt;

&lt;h3 id=&quot;nginx&quot;&gt;Nginx&lt;/h3&gt;

&lt;p&gt;配置：nginx.conf&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http{
#Fastcgi:(针对后端的fastcgi生效,fastcgi不属于proxy模式)

fastcgi_connect_timeout5;#连接超时

fastcgi_send_timeout10; #写超时

fastcgi_read_timeout10;#读取超时

#Proxy:(针对proxy/upstreams的生效)

proxy_connect_timeout15s;#连接超时

proxy_read_timeout24s;#读超时

proxy_send_timeout10s; #写超时

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;Nginx 的超时设置倒是非常清晰容易理解，上面超时针对不同工作模式，但是因为超时带来的问题是非常多的。&lt;/p&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://hi.baidu.com/pibuchou/blog/item/a1e330dd71fb8a5995ee3753.html&quot;&gt;http://hi.baidu.com/pibuchou/blog/item/a1e330dd71fb8a5995ee3753.html &lt;/a&gt; 
&lt;a href=&quot;http://hi.baidu.com/pibuchou/blog/item/7cbccff0a3b77dc60b46e024.html&quot;&gt;http://hi.baidu.com/pibuchou/blog/item/7cbccff0a3b77dc60b46e024.html &lt;/a&gt; 
&lt;a href=&quot;http://hi.baidu.com/pibuchou/blog/item/10a549818f7e4c9df703a626.html&quot;&gt;http://hi.baidu.com/pibuchou/blog/item/10a549818f7e4c9df703a626.html &lt;/a&gt; 
&lt;a href=&quot;http://www.apoyl.com/?p=466&quot;&gt;http://www.apoyl.com/?p=466  &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;php&quot;&gt;PHP本身超时处理&lt;/h2&gt;

&lt;h3 id=&quot;php-fpm&quot;&gt;PHP-fpm&lt;/h3&gt;

&lt;p&gt;配置：php-fpm.conf&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?xmlversion=”1.0″?&amp;gt;
&amp;lt;configuration&amp;gt;

//…

Setsthelimitonthenumberofsimultaneousrequeststhatwillbeserved.

EquivalenttoApacheMaxClientsdirective.

EquivalenttoPHP_FCGI_CHILDRENenvironmentinoriginalphp.fcgi

Usedwithanypm_style.

#php-cgi的进程数量

&amp;lt;valuename=”max_children”&amp;gt;128&amp;lt;/value&amp;gt;

Thetimeout(inseconds)forservingasinglerequestafterwhichtheworkerprocesswillbeterminated

Shouldbeusedwhen’max_execution_time’inioptiondoesnotstopscriptexecutionforsomereason

’0s’means’off’

#php-fpm 请求执行超时时间，0s为永不超时，否则设置一个 Ns 为超时的秒数

&amp;lt;valuename=”request_terminate_timeout”&amp;gt;0s&amp;lt;/value&amp;gt;

Thetimeout(inseconds)forservingofsinglerequestafterwhichaphpbacktracewillbedumpedtoslow.logfile

’0s’means’off’

&amp;lt;valuename=”request_slowlog_timeout”&amp;gt;0s&amp;lt;/value&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;在php.ini中，有一个参数max_execution_time可以设置PHP脚本的最大执行时间，但是，在php-cgi(php-fpm)中，该参数不会起效。真正能够控制PHP脚本最大执行时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;valuename=”request_terminate_timeout”&amp;gt;0s&amp;lt;/value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就是说如果是使用mod_php5.so的模式运行max_execution_time是会生效的，但是如果是php-fpm模式中运行时不生效的。&lt;/p&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;http://blog.s135.com/file_get_contents/&lt;/p&gt;

&lt;h3 id=&quot;php-1&quot;&gt;PHP&lt;/h3&gt;

&lt;p&gt;配置：php.ini&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;max_execution_time=30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者在代码里设置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ini_set(“max_execution_time”,30);

set_time_limit(30);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;对当前会话生效，比如设置0一直不超时，但是如果php的safe_mode打开了，这些设置都会不生效。&lt;/p&gt;

&lt;p&gt;效果一样，但是具体内容需要参考php-fpm部分内容，如果php-fpm中设置了request_terminate_timeout的话，那么max_execution_time就不生效。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;后端&amp;amp;接口访问超时&lt;/h2&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP访问&lt;/h2&gt;

&lt;p&gt;一般我们访问HTTP方式很多，主要是：curl,socket,file_get_contents()等方法。&lt;/p&gt;

&lt;p&gt;如果碰到对方服务器一直没有响应的时候，我们就悲剧了，很容易把整个服务器搞死，所以在访问http的时候也需要考虑超时的问题。&lt;/p&gt;

&lt;h3 id=&quot;curl-http&quot;&gt;CURL 访问HTTP&lt;/h3&gt;

&lt;p&gt;CURL 是我们常用的一种比较靠谱的访问HTTP协议接口的lib库，性能高，还有一些并发支持的功能等。&lt;/p&gt;

&lt;p&gt;CURL:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl_setopt($ch,opt)可以设置一些超时的设置，主要包括：

*(重要)CURLOPT_TIMEOUT设置cURL允许执行的最长秒数。

*(重要)CURLOPT_TIMEOUT_MS设置cURL允许执行的最长毫秒数。(在cURL7.16.2中被加入。从PHP5.2.3起可使用。)

CURLOPT_CONNECTTIMEOUT在发起连接前等待的时间，如果设置为0，则无限等待。

CURLOPT_CONNECTTIMEOUT_MS尝试连接等待的时间，以毫秒为单位。如果设置为0，则无限等待。在cURL7.16.2中被加入。从PHP5.2.3开始可用。

CURLOPT_DNS_CACHE_TIMEOUT设置在内存中保存DNS信息的时间，默认为120秒。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;curl普通秒级超时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ch=curl_init();

curl_setopt($ch,CURLOPT_URL,$url);

curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);

curl_setopt($ch,CURLOPT_TIMEOUT,60);//只需要设置一个秒的数量就可以

curl_setopt($ch,CURLOPT_HTTPHEADER,$headers);

curl_setopt($ch,CURLOPT_USERAGENT,$defined_vars[&#39;HTTP_USER_AGENT&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;curl普通秒级超时使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl_setopt($ch,CURLOPT_TIMEOUT,60);

curl如果需要进行毫秒超时，需要增加：

curl_easy_setopt(curl,CURLOPT_NOSIGNAL,1L);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl_setopt($ch,CURLOPT_NOSIGNAL,true);是可以支持毫秒级别超时设置的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;curl一个毫秒级超时的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
if(!isset($_GET[&#39;foo&#39;])){

//Client

$ch=curl_init(‘http://example.com/’);

curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);

curl_setopt($ch,CURLOPT_NOSIGNAL,1);//注意，毫秒超时一定要设置这个

curl_setopt($ch,CURLOPT_TIMEOUT_MS,200);//超时毫秒，cURL7.16.2中被加入。从PHP5.2.3起可使用

$data=curl_exec($ch);

$curl_errno=curl_errno($ch);

$curl_error=curl_error($ch);

curl_close($ch);

if($curl_errno&amp;gt;0){

echo”cURLError($curl_errno):$curl_errorn”;

}else{

echo”Datareceived:$datan”;

}

}else{

//Server

sleep(10);

echo”Done.”;

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他一些技巧：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;按照经验总结是：cURL版本&amp;gt;=libcurl/7.21.0版本，毫秒级超时是一定生效的，切记。&lt;/li&gt;
  &lt;li&gt;curl_multi的毫秒级超时也有问题。。单次访问是支持ms级超时的，curl_multi并行调多个会不准&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;http-1&quot;&gt;流处理方式访问HTTP&lt;/h3&gt;

&lt;p&gt;除了curl，我们还经常自己使用fsockopen、或者是file操作函数来进行HTTP协议的处理，所以，我们对这块的超时处理也是必须的。&lt;/p&gt;

&lt;p&gt;一般连接超时可以直接设置，但是流读取超时需要单独处理。&lt;/p&gt;

&lt;p&gt;自己写代码处理:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$tmCurrent=gettimeofday();

$intUSGone=($tmCurrent[&#39;sec&#39;]-$tmStart[&#39;sec&#39;])*1000000

+($tmCurrent[&#39;usec&#39;]-$tmStart[&#39;usec&#39;]);

if($intUSGone&amp;gt;$this-&amp;gt;_intReadTimeoutUS){

returnfalse;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者使用内置流处理函数stream_set_timeout()和stream_get_meta_data()处理：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php//Timeoutinseconds
$timeout=5;

$fp=fsockopen(“example.com”,80,$errno,$errstr,$timeout);

if($fp){

fwrite($fp,”GET/HTTP/1.0rn”);

fwrite($fp,”Host:example.comrn”);

fwrite($fp,”Connection:Closernrn”);

stream_set_blocking($fp,true);//重要，设置为非阻塞模式

stream_set_timeout($fp,$timeout);//设置超时

$info=stream_get_meta_data($fp);

while((!feof($fp))&amp;amp;&amp;amp;(!$info[&#39;timed_out&#39;])){

$data.=fgets($fp,4096);

$info=stream_get_meta_data($fp);

ob_flush;

flush();

}

if($info[&#39;timed_out&#39;]){

echo”ConnectionTimedOut!”;

}else{

echo$data;

}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;file_get_contents超时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php$timeout=array(
&#39;http=&amp;gt;array(

&#39;timeout&#39;=&amp;gt;5//设置一个超时时间，单位为秒

)

);

$ctx=stream_context_create($timeout);

$text=file_get_contents(&quot;http://example.com/&quot;,0,$ctx);

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;fopen超时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php$timeout=array(
&#39;http&#39;=&amp;gt;array(

&#39;timeout&#39;=&amp;gt;5//设置一个超时时间，单位为秒

)

);

$ctx=stream_context_create($timeout);

if($fp=fopen(&quot;http://example.com/&quot;,&quot;r&quot;,false,$ctx)){

while($c=fread($fp,8192)){

echo$c;

}

fclose($fp);

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL&lt;/h2&gt;

&lt;p&gt;php中的mysql客户端都没有设置超时的选项，mysqli和mysql都没有，但是libmysql是提供超时选项的，只是我们在php中隐藏了而已。&lt;/p&gt;

&lt;p&gt;那么如何在PHP中使用这个操作捏，就需要我们自己定义一些MySQL操作常量，主要涉及的常量有：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MYSQL_OPT_READ_TIMEOUT=11;

MYSQL_OPT_WRITE_TIMEOUT=12;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这两个，定义以后，可以使用options设置相应的值。&lt;/p&gt;

&lt;p&gt;不过有个注意点，mysql内部实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;超时设置单位为秒，最少配置1秒&lt;/li&gt;
  &lt;li&gt;但mysql底层的read会重试两次，所以实际会是3秒&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;重试两次+　自身一次=3倍超时时间，那么就是说最少超时时间是3秒，不会低于这个值，对于大部分应用来说可以接受，但是对于小部分应用需要优化。&lt;/p&gt;

&lt;p&gt;查看一个设置访问mysql超时的php实例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php//自己定义读写超时常量
if(!defined(‘MYSQL_OPT_READ_TIMEOUT’)){

define(‘MYSQL_OPT_READ_TIMEOUT’,11);

}

if(!defined(‘MYSQL_OPT_WRITE_TIMEOUT’)){

define(‘MYSQL_OPT_WRITE_TIMEOUT’,12);

}

//设置超时

$mysqli=mysqli_init();

$mysqli-&amp;gt;options(MYSQL_OPT_READ_TIMEOUT,3);

$mysqli-&amp;gt;options(MYSQL_OPT_WRITE_TIMEOUT,1);

//连接数据库

$mysqli-&amp;gt;real_connect(“localhost”,”root”,”root”,”test”);

if(mysqli_connect_errno()){

printf(“Connectfailed:%s/n”,mysqli_connect_error());

exit();

}

//执行查询sleep1秒不超时

printf(“Hostinformation:%s/n”,$mysqli-&amp;gt;host_info);

if(!($res=$mysqli-&amp;gt;query(‘selectsleep(1)’))){

echo”query1error:”.$mysqli-&amp;gt;error.”/n”;

}else{

echo”Query1:querysuccess/n”;

}

//执行查询sleep9秒会超时

if(!($res=$mysqli-&amp;gt;query(‘selectsleep(9)’))){

echo”query2error:”.$mysqli-&amp;gt;error.”/n”;

}else{

echo”Query2:querysuccess/n”;

}

$mysqli-&amp;gt;close();

echo”closemysqlconnection/n”;

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/heiyeshuwu/article/details/5869813&quot;&gt;http://blog.csdn.net/heiyeshuwu/article/details/5869813&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;memcached&quot;&gt;Memcached&lt;/h2&gt;

&lt;h3 id=&quot;php-2&quot;&gt;PHP扩展&lt;/h3&gt;

&lt;p&gt;php_memcache客户端：&lt;/p&gt;

&lt;p&gt;连接超时：&lt;code class=&quot;highlighter-rouge&quot;&gt;boolMemcache::connect(string$host[,int$port[,int$timeout]])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在get和set的时候，都没有明确的超时设置参数。&lt;/p&gt;

&lt;p&gt;libmemcached客户端：在php接口没有明显的超时参数。&lt;/p&gt;

&lt;p&gt;说明：所以说，在PHP中访问Memcached是存在很多问题的，需要自己hack部分操作，或者是参考网上补丁。&lt;/p&gt;

&lt;h3 id=&quot;ccmemcached&quot;&gt;C&amp;amp;C++访问Memcached&lt;/h3&gt;

&lt;p&gt;客户端：libmemcached客户端&lt;/p&gt;

&lt;p&gt;说明：memcache超时配置可以配置小点，比如5，10个毫秒已经够用了，超过这个时间还不如从数据库查询。&lt;/p&gt;

&lt;p&gt;下面是一个连接和读取set数据的超时的C++示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//创建连接超时（连接到Memcached）
memcached_st*MemCacheProxy::_create_handle()

{

memcached_st*mmc=NULL;

memcached_return_tprc;

if(_mpool!=NULL){//getfrompool

mmc=memcached_pool_pop(_mpool,false,&amp;amp;prc);

if(mmc==NULL){

__LOG_WARNING__(“MemCacheProxy”,”gethandlefrompoolerror[%d]“,(int)prc);

}

returnmmc;

}

memcached_st*handle=memcached_create(NULL);

if(handle==NULL){

__LOG_WARNING__(“MemCacheProxy”,”create_handleerror”);

returnNULL;

}

//设置连接/读取超时

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_HASH,MEMCACHED_HASH_DEFAULT);

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_NO_BLOCK,_noblock);//参数MEMCACHED_BEHAVIOR_NO_BLOCK为1使超时配置生效，不设置超时会不生效，关键时候会悲剧的，容易引起雪崩

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT,_connect_timeout);//连接超时

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_RCV_TIMEOUT,_read_timeout);//读超时

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_SND_TIMEOUT,_send_timeout);//写超时

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_POLL_TIMEOUT,_poll_timeout);

//设置一致hash

//memcached_behavior_set_distribution(handle,MEMCACHED_DISTRIBUTION_CONSISTENT);

memcached_behavior_set(handle,MEMCACHED_BEHAVIOR_DISTRIBUTION,MEMCACHED_DISTRIBUTION_CONSISTENT);

memcached_returnrc;

for(uinti=0;i&amp;lt;_server_count;i++){

rc=memcached_server_add(handle,_ips[i],_ports[i]);

if(MEMCACHED_SUCCESS!=rc){

__LOG_WARNING__(“MemCacheProxy”,”addserver[%s:%d]failed.”,_ips[i],_ports[i]);

}

}

_mpool=memcached_pool_create(handle,_min_connect,_max_connect);

if(_mpool==NULL){

__LOG_WARNING__(“MemCacheProxy”,”create_poolerror”);

returnNULL;

}

mmc=memcached_pool_pop(_mpool,false,&amp;amp;prc);

if(mmc==NULL){

__LOG_WARNING__(“MyMemCacheProxy”,”gethandlefrompoolerror[%d]“,(int)prc);

}

//__LOG_DEBUG__(“MemCacheProxy”,”gethandle[%p]“,handle);

returnmmc;

}

//设置一个key超时（set一个数据到memcached）

boolMemCacheProxy::_add(memcached_st*handle,unsignedint*key,constchar*value,intlen,unsignedinttimeout)

{

memcached_returnrc;

chartmp[1024];

snprintf(tmp,sizeof(tmp),”%u#%u”,key[0],key[1]);

//有个timeout值

rc=memcached_set(handle,tmp,strlen(tmp),(char*)value,len,timeout,0);

if(MEMCACHED_SUCCESS!=rc){

returnfalse;

}

returntrue;

}

//Memcache读取数据超时(没有设置)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;libmemcahed源码中接口定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LIBMEMCACHED_APIchar*memcached_get(memcached_st*ptr,constchar*key,size_tkey_length,size_t*value_length,uint32_t*flags,memcached_return_t*error);

LIBMEMCACHED_APImemcached_return_tmemcached_mget(memcached_st*ptr,constchar*const*keys,constsize_t*key_length,size_tnumber_of_keys);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从接口中可以看出在读取数据的时候，是没有超时设置的。&lt;/p&gt;

&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://hi.baidu.com/chinauser/item/b30af90b23335dde73e67608&quot;&gt;http://hi.baidu.com/chinauser/item/b30af90b23335dde73e67608  &lt;/a&gt;
&lt;a href=&quot;http://libmemcached.org/libMemcached.html&quot;&gt;http://libmemcached.org/libMemcached.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;如何实现超时&lt;/h2&gt;

&lt;p&gt;程序中需要有超时这种功能，比如你单独访问一个后端Socket模块，Socket模块不属于我们上面描述的任何一种的时候，它的协议也是私有的，那么这个时候可能需要自己去实现一些超时处理策略，这个时候就需要一些处理代码了。&lt;/p&gt;

&lt;h3 id=&quot;php-3&quot;&gt;PHP中超时实现&lt;/h3&gt;

&lt;p&gt;一、初级：最简单的超时实现 （秒级超时）&lt;/p&gt;

&lt;p&gt;思路很简单：链接一个后端，然后设置为非阻塞模式，如果没有连接上就一直循环，判断当前时间和超时时间之间的差异。&lt;/p&gt;

&lt;p&gt;phpsocket中实现原始的超时：(每次循环都当前时间去减，性能会很差，cpu占用会较高)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?$host=”127.0.0.1″;
$port=”80″;

$timeout=15;//timeoutinseconds

$socket=socket_create(AF_INET,SOCK_STREAM,SOL_TCP)

ordie(“Unabletocreatesocketn”);

socket_set_nonblock($socket) //务必设置为阻塞模式

ordie(“Unabletosetnonblockonsocketn”);

$time=time();

//循环的时候每次都减去相应值

while(!@socket_connect($socket,$host,$port))//如果没有连接上就一直死循环

{

$err=socket_last_error($socket);

if($err==115||$err==114)

{

if((time()-$time)&amp;gt;=$timeout)//每次都需要去判断一下是否超时了

{

socket_close($socket);

die(“Connectiontimedout.n”);

}

sleep(1);

continue;

}

die(socket_strerror($err).”n”);

}

socket_set_block($this-&amp;gt;socket)//还原阻塞模式

ordie(“Unabletosetblockonsocketn”);

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;二、升级：使用PHP自带异步IO去实现（毫秒级超时）&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;异步IO：异步IO的概念和同步IO相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。异步IO将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方从不知道它们会在什么时候到达。&lt;/p&gt;

&lt;p&gt;多路复用：复用模型是对多个IO操作进行检测，返回可操作集合，这样就可以对其进行操作了。这样就避免了阻塞IO不能随时处理各个IO和非阻塞占用系统资源的确定。&lt;/p&gt;

&lt;p&gt;使用socket_select()实现超时&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;socket_select(…,floor($timeout),ceil($timeout*1000000));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;select的特点：能够设置到微秒级别的超时！&lt;/p&gt;

&lt;p&gt;使用socket_select()的超时代码（需要了解一些异步IO编程的知识去理解）&lt;/p&gt;

&lt;p&gt;编程 调用类 编程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

$server=newServer;

$client=newClient;

for(;;){

foreach($select-&amp;gt;can_read(0)as$socket){

if($socket==$client-&amp;gt;socket){

//NewClientSocket

$select-&amp;gt;add(socket_accept($client-&amp;gt;socket));

}

else{

//there’ssomethingtoreadon$socket

}

}

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编程 异步多路复用IO &amp;amp; 超时连接处理类 编程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

classselect{

var$sockets;

functionselect($sockets){

$this-&amp;gt;sockets=array();

foreach($socketsas$socket){

$this-&amp;gt;add($socket);

}

}

functionadd($add_socket){

array_push($this-&amp;gt;sockets,$add_socket);

}

functionremove($remove_socket){

$sockets=array();

foreach($this-&amp;gt;socketsas$socket){

if($remove_socket!=$socket)

$sockets[]=$socket;

}

$this-&amp;gt;sockets=$sockets;

}

functioncan_read($timeout){

$read=$this-&amp;gt;sockets;

socket_select($read,$write=NULL,$except=NULL,$timeout);

return$read;

}

functioncan_write($timeout){

$write=$this-&amp;gt;sockets;

socket_select($read=NULL,$write,$except=NULL,$timeout);

return$write;

}

}

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cc&quot;&gt;C&amp;amp;C++中超时实现&lt;/h3&gt;

&lt;p&gt;一般在LinuxC/C++中，可以使用：alarm()设置定时器的方式实现秒级超时，或者：select()、poll()、epoll()之类的异步复用IO实现毫秒级超时。也可以使用二次封装的异步io库（libevent,libev）也能实现。&lt;/p&gt;

&lt;p&gt;一、使用alarm中用信号实现超时 （秒级超时）&lt;/p&gt;

&lt;p&gt;说明：Linux内核connect超时通常为75秒，我们可以设置更小的时间如10秒来提前从connect中返回。这里用使用信号处理机制，调用alarm，超时后产生SIGALRM信号（也可使用select实现）&lt;/p&gt;

&lt;p&gt;用alarym秒级实现　connect设置超时代码示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//信号处理函数staticvoidconnect_alarm(intsigno)
{

debug_printf(“SignalHandler”);

return;

}

//alarm超时连接实现

staticvoidconn_alarm()

{

Sigfunc*sigfunc;//现有信号处理函数

sigfunc=signal(SIGALRM,connect_alarm);//建立信号处理函数connect_alarm,(如果有)保存现有的信号处理函数

inttimeout=5;

//设置闹钟

if(alarm(timeout)!=0){

//…闹钟已经设置处理

}

//进行连接操作

if(connect(m_Socket,(structsockaddr*)&amp;amp;addr,sizeof(addr))&amp;lt;0){

if(errno==EINTR){//如果错误号设置为EINTR，说明超时中断了

debug_printf(“Timeout”);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 15 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/15/PHP%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/15/PHP%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/</guid>
        
        <category>Francis 杂谈</category>
        
        <category>PHP</category>
        
        <category>C</category>
        
        
      </item>
    
      <item>
        <title>忙忙碌碌，虚虚实实的生活</title>
        <description>&lt;p&gt;最近太忙碌了，工作忙，学习忙，以后的三年没有周末了。现在的周末比平时都要忙，仿佛一夜之间恢复到了学生时代，在我还没有做好迎接它的时候。&lt;/p&gt;

&lt;p&gt;现在才发现时间真的是太珍贵了，虚度光阴的日子不能再重复了。也好，让自己的生活更充实一些。&lt;/p&gt;

&lt;p&gt;如果简单点想的话，其实没有那么可怕，相信自己会逐步适应这种节奏。&lt;/p&gt;

&lt;p&gt;数学中有种思想叫化归，更适合作为我现在的指导思想。&lt;/p&gt;

&lt;p&gt;来，听首我最喜欢的钢琴曲吧。继续前行！&lt;/p&gt;

&lt;audio controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&gt;
  &lt;source src=&quot;http://source.francissoung.com/music%2FPure%20Music%20-%20%E5%8D%A1%E5%86%9C.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;
Your browser does not support the audio tag.
&lt;/audio&gt;

</description>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/14/%E5%BF%99%E5%BF%99%E7%A2%8C%E7%A2%8C-%E8%99%9A%E8%99%9A%E5%AE%9E%E5%AE%9E%E7%9A%84%E7%94%9F%E6%B4%BB/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/14/%E5%BF%99%E5%BF%99%E7%A2%8C%E7%A2%8C-%E8%99%9A%E8%99%9A%E5%AE%9E%E5%AE%9E%E7%9A%84%E7%94%9F%E6%B4%BB/</guid>
        
        <category>Francis 简单生活</category>
        
        
      </item>
    
      <item>
        <title>不要为自己选择的道路而后悔</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;自己选择的路，再艰难也要走下去，不要为自己选择的道路而后悔，摔跤了不要哭，再爬起来，站直一笑，拍拍尘灰继续奔跑!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;永远都不要去为自己选择的道路而后悔，不管是十年前还是现在&lt;/strong&gt;。控制好心情生活才会处处祥和。好心态塑造好心情，好心情塑造最出色的自己。过去的别再遗憾;未来的无须忧虑;现在的加倍珍惜。摔跤了不要哭，再爬起来，站直一笑，拍拍尘灰继续奔跑。正视人生的每一个挫折适应人生的每一回起伏，吸取人生的每一场失败利用人生的每一个坎坷。&lt;/p&gt;

&lt;p&gt;等待太久得来的东西多半已经不是当初自己想要的样子了。我们都在时光里跌跌撞撞地成长然后一点点离开最初的模样。所谓的朋友就是在你浑身的缺点里，也能看到所剩的优点，然后一捧土一捧土地把你从绝望无助肮脏复杂里拉出来。告诉你，你很好，你值得被人爱。但也会拍拍你的肩膀，你要注意脚下的坑，若绕过就不会摔得鼻青脸肿。&lt;/p&gt;

&lt;p&gt;不要由于别人不能成为你所希望的人而愤怒，因为你自己也不能成为自己所希望的人。总是活在一些极致的情绪里，某一段时间会对生活充满了信心，但突然在某一瞬间，你又会全盘推翻。你有信心时，无所不能，而你推翻这一切的时候，也是百分之百的灰心。&lt;/p&gt;

&lt;p&gt;有时候，最难放下的是一些你从没真正拥有过的事。有时候你把什么放下了，不是因为突然就舍得了，而是因为期限到了，任性够了成熟多了，也就知道这一页该翻过去了。失败时有人伸出一只手来为你擦泪，会好过成功时无数人伸手为你鼓掌。&lt;/p&gt;

&lt;p&gt;有些事，会让你用眼泪哭。有些事，会让你埋在心底里哭。有些事，会让你整个灵魂哭。我们每一个人，都会遇见绝望和痛苦，所有人都会哭，而流泪往往不是最伤心的。你可能心丧若死，却面无表情，枯坐了几天，才突然哭出来，泪水流下时，你才是得救了。眼泪是心里的毒，流出来就好了。&lt;/p&gt;

&lt;p&gt;接下来的日子里，我要做的只有一件事，把自己变得优秀。努力给自己一个最美好的心情，平衡住自己的气息，调整好自己的心态，不急于成功之事，就算摔了再大的跤，也一样能成为明天的更好。学着看淡一些事情，才是对自己最好的保护。&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/14/%E4%B8%8D%E8%A6%81%E4%B8%BA%E8%87%AA%E5%B7%B1%E9%80%89%E6%8B%A9%E7%9A%84%E9%81%93%E8%B7%AF%E8%80%8C%E5%90%8E%E6%82%94/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/14/%E4%B8%8D%E8%A6%81%E4%B8%BA%E8%87%AA%E5%B7%B1%E9%80%89%E6%8B%A9%E7%9A%84%E9%81%93%E8%B7%AF%E8%80%8C%E5%90%8E%E6%82%94/</guid>
        
        <category>Francis 简单生活</category>
        
        
      </item>
    
      <item>
        <title>国内常用公共DNS服务器、各省运营商DNS服务器汇总</title>
        <description>&lt;p&gt;不知道大家有没有过网络是正常的，QQ可以正常登录、游戏也可以正常玩，但是网页无论如何都打不开。这就是电脑网络设置的DNS服务器有问题，不是其故障就是不工作了。&lt;/p&gt;

&lt;p&gt;换了DNS服务器成功解决问题。下边给大家分享一下国内比较大型大众常用的公共DNS服务器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;公共DNS服务器，即系统默认的DNS解析服务器。DNS全称Domain Name System，即域名解析系统。DNS帮助用户在互联网上寻找路径。在互联网上的每一个计算机都拥有一个唯一的地址，称作“IP地址”（即互联网协议地址）。
由于IP地址（为一串数字）不方便记忆，DNS允许用户使用一串常见的字母（即“域名”）取代。
公共DNS服务器，具有无广告、可以在一定程度上防止DNS劫持、不需因上网环境的改变而改变等优势，但是，使用公共DNS也可能存在系统响应慢、被劫持、隐私问题等风险。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://source.francissoung.com/2016%2F03%2F14%2F%E5%9B%BD%E5%86%85%E5%B8%B8%E7%94%A8%E5%85%AC%E5%85%B1DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E5%90%84%E7%9C%81%E8%BF%90%E8%90%A5%E5%95%86DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B1%87%E6%80%BB1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里要说一下，更换或者使用DNS服务器只能做到可以打开浏览网页，不能扶墙，博主居然还看到有极少数提供商号称支持番羽土番。&lt;/p&gt;

&lt;p&gt;虽然公共DNS有一定防DNS劫持作用，但是随着“墙”的升级，这种作用已经很微弱了——无论你是使用ISP的默认DNS，还是使用国外的公共DNS服务器，解析诸如twitter.com之类的域名所得到的结果均会受到DNS污染。&lt;/p&gt;

&lt;p&gt;114 DNS（http://www.114dns.com/），这应该是用户数量数一数二的公共DNS了，档主自己也在使用，推荐。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;114.114.114.114&lt;/p&gt;

  &lt;p&gt;114.114.115.115&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;阿里 AliDNS（http://www.alidns.com/），来自阿里巴巴和马云旗下的公共DNS，还没有体验过，有兴趣可以试试。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;223.5.5.5&lt;/p&gt;

  &lt;p&gt;223.6.6.6&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CNNIC SDNS（http://www.sdns.cn/），来自天朝官方CNNIC的公共DNS，没使用过也没敢用……&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.2.4.8&lt;/p&gt;

  &lt;p&gt;210.2.4.8&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;oneDNS（http://www.onedns.net/），2013年才新推出的一个公共DNS服务器，官网介绍由恶意网站实验室创立，没用过。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;112.124.47.27&lt;/p&gt;

  &lt;p&gt;114.215.126.16&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Google DNS（https://developers.google.com/speed/public-dns/），曾经最火最热的一款公共DNS服务器，但是随着Google在中国的没落和国内官方的限制，已经不是太好用了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;8.8.8.8&lt;/p&gt;

  &lt;p&gt;8.8.4.4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;OpenDNS（https://www.opendns.com/），和Google DNS 一样，来自于国外服务商提供的公共DNS，据说同样在国内水土不服。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;208.67.222.222&lt;/p&gt;

  &lt;p&gt;208.67.220.220&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;以下是全国各地电信 DNS 服务器 IP 地址&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;安徽电信 DNS

61.132.163.68
202.102.213.68

北京电信 DNS

219.141.136.10
219.141.140.10

重庆电信 DNS

61.128.192.68
61.128.128.68

福建电信 DNS

218.85.152.99
218.85.157.99

甘肃电信 DNS

202.100.64.68
61.178.0.93

广东电信 DNS

202.96.128.86
202.96.128.166
202.96.134.33
202.96.128.68

广西电信 DNS

202.103.225.68
202.103.224.68

贵州电信 DNS

202.98.192.67
202.98.198.167

河南电信 DNS

222.88.88.88
222.85.85.85

黑龙江电信 DNS

219.147.198.230
219.147.198.242

湖北电信 DNS

202.103.24.68
202.103.0.68

湖南电信 DNS

222.246.129.80
59.51.78.211

江苏电信 DNS

218.2.2.2
218.4.4.4
61.147.37.1
218.2.135.1

江西电信 DNS

202.101.224.69
202.101.226.68

内蒙古电信

219.148.162.31
222.74.39.50

山东电信 DNS

219.146.0.130
219.150.32.132

陕西电信 DNS

218.30.19.40
61.134.1.4

上海电信 DNS

202.96.209.133
116.228.111.118
202.96.209.5
108.168.255.118

四川电信 DNS

61.139.2.69
218.6.200.139

天津电信 DNS

219.150.32.132
219.146.0.132

云南电信 DNS

222.172.200.68
61.166.150.123

浙江电信 DNS

202.101.172.35
61.153.177.196
61.153.81.75
60.191.244.5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以下为全国各地联通 DNS 服务器 IP 地址&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;北京联通 DNS

202.106.196.115
202.106.46.151
202.106.0.20
202.106.195.68

重庆联通 DNS

221.5.203.98
221.7.92.98

广东联通 DNS

210.21.196.6
221.5.88.88

河北联通 DNS

202.99.160.68
202.99.166.4

河南联通 DNS

202.102.224.68
202.102.227.68

黑龙江联通

202.97.224.69
202.97.224.68

吉林联通 DNS

202.98.0.68
202.98.5.68

江苏联通 DNS

221.6.4.66
221.6.4.67

内蒙古联通

202.99.224.68
202.99.224.8

山东联通 DNS

202.102.128.68
202.102.152.3
202.102.134.68
202.102.154.3

山西联通 DNS

202.99.192.66
202.99.192.68

陕西联通 DNS

221.11.1.67
221.11.1.68

上海联通 DNS

210.22.70.3
210.22.84.3

四川联通 DNS

119.6.6.6
124.161.87.155

天津联通 DNS

202.99.104.68
202.99.96.68

浙江联通 DNS

221.12.1.227
221.12.33.227
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;http://www.fulidang.com/3036.html&quot;&gt;【技术控】国内常用公共DNS服务器、各省运营商DNS服务器&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/14/%E5%B8%B8%E7%94%A8%E5%85%AC%E5%85%B1DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/14/%E5%B8%B8%E7%94%A8%E5%85%AC%E5%85%B1DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
        
        <category>Francis 杂谈</category>
        
        
      </item>
    
      <item>
        <title>使用Jekyll+GitHub搭建自己的免费静态博客</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;是一个代码托管网站，现在很多开源项目都放在GitHub上。 利用GitHub，可以让全球各地的程序员们一起协作开发。GitHub 提供了一种功能，叫 &lt;a href=&quot;https://help.github.com/categories/20/articles&quot;&gt;GitHub Pages&lt;/a&gt;, 利用这个功能，我 们可以为项目建立网站，当然，这也意味着我们可以通过 GitHub Pages 建立自己的网站。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;是一个简单的，针对博客设计的静态网站生成器。使用 GitHub 和 Jekyll，我们可以打造自己的独立博客，你可以自由地定制网站的风格，并且这 一切都是免费的。&lt;/p&gt;

&lt;p&gt;我在GitHub上建立的&lt;a href=&quot;http://francissoung.github.io&quot; title=&quot;Francis Soung&quot;&gt;博客&lt;/a&gt;及&lt;a href=&quot;https://github.com/FrancisSoung/francissoung.github.io&quot; title=&quot;Francis Soung&quot;&gt;源代码&lt;/a&gt;，可供大家fork.&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&quot;http://huangxuan.me/&quot;&gt;Hux&lt;/a&gt;带来这么漂亮的模板.也向对此模板做出贡献的Developer表示感谢.&lt;/p&gt;

&lt;p&gt;网站截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F09%2Ffrancissounghomepage.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;入门指引&lt;/h3&gt;

&lt;p&gt;GitHub Pages 的 &lt;a href=&quot;http://pages.github.com/&quot;&gt;主页&lt;/a&gt; 提供了一个简单的入门指引，阅读并 操作一下，会有一个直观简单的认识。&lt;/p&gt;

&lt;p&gt;阮一峰前辈的文章《&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&quot;&gt;搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门&lt;/a&gt;》是使用 GitHub 和 Jekyll 搭建独立博客非常好的入门文章，强烈建议先阅读并操作一遍。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;建立自己的博客&lt;/h3&gt;

&lt;p&gt;在学习完阮一峰前辈的文章后，你就已经有能力搭建自己的独立博客了，但是这个博客 只有最基本的功能，并且也不好看。这时候，你面临几个选择:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完全自己定制博客&lt;/li&gt;
  &lt;li&gt;找一份框架，修改后使用&lt;/li&gt;
  &lt;li&gt;从GitHub上fork别人的博客代码，在其中添加自己的文章&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果选择 2, 那么 &lt;a href=&quot;http://jekyllbootstrap.com/&quot;&gt;jekyll-bootstrap&lt;/a&gt;是一个选择。&lt;/p&gt;

&lt;p&gt;如果选择 3, 那么自己Google一下 github.io 博客 能找到不少博客,去fork,然后修改一下就好。&lt;/p&gt;

&lt;p&gt;如果选择 1, 那么可以好好看看后文的内容。&lt;/p&gt;

&lt;h3 id=&quot;github--jekyll-&quot;&gt;GitHub + Jekyll 工作机制&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;机制一&lt;/h4&gt;

&lt;p&gt;简单地说，你在 GitHub 上有一个账号，名为username(任意)， 有一个项目，名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io&lt;/code&gt;(固定格式，username与账号名一致)， 项目分支名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;(固定)，这个分支有着类似下面的 目录结构:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── index.html
├── _config.yml
├── assets
│   ├── blog-images
│   ├── css
│   ├── fonts
│   ├── images
│   └── javascripts
├── _includes
├── _layouts
├── _plugins
├── _posts
└── _site
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，当你访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://username.github.io/&lt;/code&gt;时，GitHub 会使用 Jekyll 解析 用户 username名下的username.github.io项目中，分支为master 的源代码，为你构建一个静态网站，并将生成的 index.html 展示给你。&lt;/p&gt;

&lt;p&gt;关于这个目录更多的内容，我们还不需要关心，如果你好奇心比较重，可以先看后文源代码一节。&lt;/p&gt;

&lt;p&gt;看完上面的解释，你可能会有一些疑问，因为按照上面的说法，一个用户只能有一个网站，那我有很多项目，每个项目都需要一个项目网站，该怎么办呢？另外，在阮一峰前辈的文章中，特别提到，分支名应该为 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt;，这又是怎么回事呢？&lt;/p&gt;

&lt;p&gt;原来，GitHub认为，一个GitHub账号对应一个用户或者一个组织，GitHub会 给这个用户分配一个域名：&lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io&lt;/code&gt;，当用户访问这个域名时， GitHub会去解析username用户下，&lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io&lt;/code&gt;项目的master分支， 这与我们之前的描述一致。&lt;/p&gt;

&lt;p&gt;另外，GitHub还为每个项目提供了域名，例如，你有一个项目名为blog， GitHub为这个项目提供的域名为&lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io/blog&lt;/code&gt;， 当你访问这个域名时，GitHub会去解析username用户下，blog项目的gh-pages 分支。&lt;/p&gt;

&lt;p&gt;所以，要搭建自己的博客，你可以选择建立名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io&lt;/code&gt;的项目， 在&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支下存放网站源代码，也可以选择建立名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;blog&lt;/code&gt; 的项目，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt;分支下存放网站源代码。&lt;/p&gt;

&lt;p&gt;GitHub 的 Help 文档中的 &lt;a href=&quot;https://help.github.com/articles/user-organization-and-project-pages&quot;&gt;User, Organization and Project Pages&lt;/a&gt;对此有 详细的描述。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;机制二&lt;/h4&gt;

&lt;p&gt;Jekyll 提供了插件功能，在网站源代码目录下，有一个名为 _plugins的目录，你可以将一些插件放进去，这样，Jekyll在解析网站源代码时，就会运行你的插件，这样插件是 Ruby 写成的。可以为Jekyll添加功能，例如，Jekyll默认是不提供分类页面的，你可以写一个插件，根据文章内容生成分类页面。如果没有插件，你只能每次写文章添加分类时为每个分类手动写HTML页面。&lt;/p&gt;

&lt;p&gt;在本地运行 Jekyll 时，这些插件会自动被调用，但是GitHub在解析网站源代码时，出于安全考虑，会开启安全模式，禁用这些插件。我们既想用这些插件，又想用 GitHub，怎么办呢怎么办呢？&lt;/p&gt;

&lt;p&gt;GitHub还为我们提供了更一种解析网站的方式，那就是直接上传最终的静态网页，这样，我们可以在本地使用 Jeklly 把网站解析出来，然后再上传到 GitHub上， 这就使得我们既使用了插件，又使用了 GitHub。在上文的目录结构中，有一个 名为 _site 的目录，这个就是Jeklly在本地解析时最终生成的静态网站，我们把其中的内容上传到 GitHub 的项目中就可以了。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;工作流&lt;/h3&gt;

&lt;p&gt;关于 git 和 jekyll 的安装与基本使用，这里就不多说了。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;工作流一&lt;/h4&gt;

&lt;p&gt;如果你不使用插件，那么只需要维护一个分支就好:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- username/username.github.io 的 master 分支
- username/blog 的 gh-pages 分支
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 username 是你的 GitHub 帐号。&lt;/p&gt;

&lt;p&gt;你需要在本地维护一份网站源代码，添加新文章后，使用 jekyll 在本地测试一下，没有问题后，commit 到 GitHub 上的相应分支中就可以了。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;工作流二&lt;/h4&gt;

&lt;p&gt;如果你需要使用插件，那么需要维护两个分支，一个是网站的源代码分支，另一个 是 Jeklly 解析源代码后生成的静态网站。&lt;/p&gt;

&lt;p&gt;例如，我的源代码分支名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;，静态网站分支名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt;。平时写博客时， 首先在 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支下，添加新文章，然后本地使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt; 将添加文章后的网站 解析一次，这时 &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; 目录下就有新网站的静态代码了。然后把这个目录下的所有内容 复制到 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt; 分支下。这个过程，可以写一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;，每次添加文章后 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 一下， 就自动将文章发布到 GitHub 上。&lt;/p&gt;

&lt;p&gt;Makefile 内容如下：&lt;/p&gt;

&lt;p&gt;deploy:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout master
git add -A
git commit -m &quot;deploy blog&quot;
cp -r _site/ /tmp/
git checkout gh-pages
rm -r ./*
cp -r /tmp/_site/* ./
git add -A
git commit -m &quot;deploy blog&quot;
git push origin gh-pages
git checkout master
echo &quot;deploy succeed&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面的内容涉及源代码，如果需要进一步学习，或者有问题，可以在 &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jeklly&lt;/a&gt; 官网上找到更详细的解释，或者在评论中留言。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;源代码&lt;/h3&gt;

&lt;p&gt;再来看一下这个目录结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── _config.yml
├── index.html
├── assets
│   ├── blog-images
│   ├── css
│   ├── fonts
│   ├── images
│   └── javascripts
├── _includes
├── _layouts
├── _plugins
├── _posts
└── _site
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;configyml&quot;&gt;_config.yml&lt;/h4&gt;

&lt;p&gt;这是针对 Jekyll 的&lt;a href=&quot;http://jekyllrb.com/docs/configuration/&quot;&gt;配置文件&lt;/a&gt;， 决定了 Jekyll 如何解析网站的源代码,下面是一个示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;baseurl: /StrayBirds
markdown: redcarpet
safe: false
pygments: true
excerpt_separator: &quot;\n\n\n&quot;
paginate: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我的网站建立在 StrayBirds 项目中，所以 baseurl 设置成 StrayBirds， 我的文章采用 Markdown 格式写成，可以指定 Markdown 的解析器 redcarpet。 另外，安全模式需要关闭，以便 Jekyll 解析时会运行插件。 pygments 可以使得Jekyll解析文章中源代码时加入特殊标记，例如指定代码类型， 这可以被很多 javascript 代码高度库使用。 excerpt_separator 指定了一个摘要分割符号，这样 Jekyll 可以在解析文章时， 将文章的提要提取出来。 paginate 指定了一页有几篇文章，页数太多时，我们可以将文章列表分页，我们在 后文还会提到。&lt;/p&gt;

&lt;h4 id=&quot;layouts&quot;&gt;_layouts&lt;/h4&gt;

&lt;p&gt;这个目录存放着一些网页模板文件，为网站所有网页提供一个基本模板，这样 每个网页只需要关心自己的内容就好，其它的都由模板决定。例如，这个目录下的 default.html 文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;{{ page.title }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;header&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/header&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;aside&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/aside&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;article&amp;gt;&lt;/span&gt;
{{ content }}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/article&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;footer&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/footer&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出，这个文件就是所有页面共有的东西，每个页面的具体内容会被填充在&lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;中，注意这个&lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;两边的标记，这是一种叫&lt;code class=&quot;highlighter-rouge&quot;&gt;liquid&lt;/code&gt;的标记语言。 另外，还有那个&lt;code class=&quot;highlighter-rouge&quot;&gt;page.title&lt;/code&gt;，其中 page 表示引用 default.html的 那个页面，这个页面的 title 值会在 page 相应页面中被设置，例如 下面的 index.html 文件，开头部分就设置了 title值。&lt;/p&gt;

&lt;h4 id=&quot;indexhtml&quot;&gt;index.html&lt;/h4&gt;

&lt;p&gt;这是网站的首页，访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://username.github.io&lt;/code&gt; 时，会指向 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://username.github.io/index.html&lt;/code&gt;，我们看一下基本内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: default
title: 首页
---


&amp;lt;ul class=&quot;post-list&quot;&amp;gt;
    {% for post in site.posts %}
        &amp;lt;a href=&quot;{{site.baseurl}}{{post.url}}&quot;&amp;gt; {{ post.title }}  &amp;lt;/a&amp;gt; &amp;lt;br&amp;gt;
        {{ post.date | date: &quot;%F&quot; }} &amp;lt;br&amp;gt;
        {{ post.category }} &amp;lt;br&amp;gt;
        {{ post.excerpt }} 
    {% endfor %}

&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意，文件开头的描述，我们称之为 &lt;a href=&quot;http://jekyllrb.com/docs/frontmatter/&quot;&gt;front-matter&lt;/a&gt;， 是对当前文件的一种描述，这里 设置的变量可以在解析时被引用，例如这里的 layout就会告诉 Jekyll, 生成 index.html 文件时，去 _layouts 目录下找 default.html 文件，然后把当前文件解析后，添加到 default.html 的 content 部分，组成最终的 index.html 文件。还有title 设置好的 值，会在 default.html 中通过 page.title 被引用。&lt;/p&gt;

&lt;p&gt;文件的主体部分遍历了站点的所有文章，并将他们显示出来，这些语法都是 liquid 语法， 其中的变量，例如 site, 由 Jekyll 设置我们只需要引用就可以了。而 post 中的变量， 如 post.title, post.category 是由 post 文件中的 front-matter 决定，后面马上就会看到。&lt;/p&gt;

&lt;h4 id=&quot;posts&quot;&gt;_posts&lt;/h4&gt;

&lt;p&gt;这个目录存放我们的所有博客文章，他们的名字有统一的格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YEAR-MONTH-DAY-title.markdown
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如，2014-02-15-github-jeklly.markdown，这个文件名会被解析，前面的 index.html 中， post.date 的值就由这里文件名中的日期而来。下面，我们看看一篇文章的内容示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: default
title: 使用 Markdown
category: 工具
comments: true
---
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;为什么使用 Markdown&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;看上去不错&lt;/li&gt;
  &lt;li&gt;既然看上去不错，为什么不试试呢&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如何使用 Markdown&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以看出，文章的 front-matter 部分设置了多项值，以后可以通过类似 &lt;code class=&quot;highlighter-rouge&quot;&gt;post.title, post.category&lt;/code&gt; 的方式引用这些些，另外，layout部分的值和之前解释的一样， 文件的内容会被填充到 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts/default.html&lt;/code&gt; 文件的 &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt; 变量中。&lt;/p&gt;

&lt;p&gt;另外，文章中 为什么不试试呢之后的有三个不可见的 \n，它决定了这三个 \n 之前的内容会被放在 post.excerpt 变量中，供其它文件使用。&lt;/p&gt;

&lt;h4 id=&quot;includes&quot;&gt;_includes&lt;/h4&gt;

&lt;p&gt;这个文件中，存放着一些模块文件，例如 categories.ext，其它文件可以通过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;categories.ext&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;来引用这个文件的内容，方便代码模块化和重用。&lt;/p&gt;

&lt;h4 id=&quot;plugins&quot;&gt;_plugins&lt;/h4&gt;

&lt;p&gt;这个文件中存放一些Ruby插件, 例如 gen_categories.rb，这些文件会在 Jekyll 解析网站源代码时被执行。下一节讲述的就是插件。&lt;/p&gt;

&lt;h4 id=&quot;site&quot;&gt;_site&lt;/h4&gt;

&lt;p&gt;Jekyll 解析整个网站源代码后，会将最终的静态网站源代码放在这里。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;插件&lt;/h3&gt;

&lt;p&gt;插件使用 Ruby 写成，放在 _plugins 目录下，有些 Jekyll 没有的功能，又不能 手动添加，因为页面的内容会随着文章日期类别的不同而不同，例如分类功能和归档功能， 这时，就需要使用插件自动生成一些页面和目录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分类插件推荐使用 &lt;a href=&quot;https://github.com/shigeya/jekyll-category-archive-plugin/tree/master/_plugins&quot;&gt;jekyll-category-archive-plugin&lt;/a&gt;, 它会根据网站文章的分类信息，为每个类别生成一个页面。&lt;/p&gt;

&lt;p&gt;使用方法是，把 &lt;code class=&quot;highlighter-rouge&quot;&gt;plugins/categoryarchive_plugin.rb&lt;/code&gt; 放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;plugins&lt;/code&gt; 目录下， 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts/categoryarchive.html&lt;/code&gt; 放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;layouts&lt;/code&gt; 目录下， 这样，这个插件会在Jekyll解析网站时，生成相应categories目录，目录下是各个分类， 每个分类下都有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 文件，这个文件是根据模板文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;categoryarchive.html&lt;/code&gt; 生成的，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_site/categories/
├── 工具
│   └── index.html
├── 思想
│   └── index.html
├── 技术
│   └── index.html
└── 源代码阅读
    └── index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，你就可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://username.github.io/blog/categories/工具/&lt;/code&gt; 访问 工具类下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;归档&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;归档插件推荐使用 &lt;a href=&quot;https://github.com/shigeya/jekyll-monthly-archive-plugin&quot;&gt;jekyll-monthly-archive-plugin&lt;/a&gt;,它会根据网站 _posts目录下的文章日期，为每个月生成一个页面。&lt;/p&gt;

&lt;p&gt;使用方法同上。注意，这个插件在 jekyll-1.4.2 中可能会出错，在 jekyll-1.2.0 中没有错误。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;组件&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;分页&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当文章很多时，就需要使用分页功能，在 Jekyll 官网上提供了一种 &lt;a href=&quot;http://jekyllrb.com/docs/pagination/&quot;&gt;实现&lt;/a&gt;，把相应代码放在 主页上，然后在 &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; 中设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;paginate&lt;/code&gt; 值就行了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;评论&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;评论功能需要使用社会化评论系统，我使用的是 &lt;a href=&quot;http://disqus.com/&quot;&gt;DISQUS&lt;/a&gt;, 注册 之后，将评论区的一段代码放在你需要使用评论功能的页面上, 然后，通过在页面的 front-matter 部分使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;comments: true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启用评论。&lt;/p&gt;

&lt;p&gt;评论区截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F09%2Fdisqus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;自定义域名解析&lt;/h3&gt;

&lt;p&gt;这里很简单了，在你的网站根目录中新建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;CNAME&lt;/code&gt;的文件，&lt;strong&gt;注：一定要大写&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F09%2FCNAME.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在CNAME文件中添加你要解析的域名。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F09%2FCNAME1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;获取GitHub Page的IP地址，最好的方法就是ping一下你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;username.github.io&lt;/code&gt; 域名。&lt;/p&gt;

&lt;p&gt;最后在你的域名提供商域名管理系统中添加对应的解析。我这里做了一个CNAME，可直接解析到A记录到IP即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F09%2FCNAME3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基本的内容就介绍到这里，任何问题，欢迎留言。&lt;/p&gt;

</description>
        <pubDate>Wed, 09 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/09/%E4%BD%BF%E7%94%A8Jekyll+GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/09/%E4%BD%BF%E7%94%A8Jekyll+GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</guid>
        
        <category>GitHub</category>
        
        <category>Francis 杂谈</category>
        
        
      </item>
    
      <item>
        <title>nginx.conf配置文件详解</title>
        <description>&lt;p&gt;Nginx配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置），每部分包含若干个指令。main部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。&lt;/p&gt;

&lt;p&gt;当前nginx支持的几个指令上下文：&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;通用&lt;/h3&gt;

&lt;p&gt;下面的nginx.conf简单的实现nginx在前端做反向代理服务器的例子，处理js、png等静态文件，jsp等动态请求转发到其它服务器tomcat：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user  www www;
worker_processes  2;
error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
pid        logs/nginx.pid;
events {
    use epoll;
    worker_connections  2048;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
    #access_log  logs/access.log  main;
    sendfile        on;
    # tcp_nopush     on;
    keepalive_timeout  65;
  # gzip压缩功能设置
    gzip on;
    gzip_min_length 1k;
    gzip_buffers    4 16k;
    gzip_http_version 1.0;
    gzip_comp_level 6;
    gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;
    gzip_vary on;
  
  # http_proxy 设置
    client_max_body_size   10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   75;
    proxy_send_timeout   75;
    proxy_read_timeout   75;
    proxy_buffer_size   4k;
    proxy_buffers   4 32k;
    proxy_busy_buffers_size   64k;
    proxy_temp_file_write_size  64k;
    proxy_temp_path   /usr/local/nginx/proxy_temp 1 2;
  # 设定负载均衡后台服务器列表 
    upstream  backend  { 
              #ip_hash; 
              server   192.168.10.100:8080 max_fails=2 fail_timeout=30s ;  
              server   192.168.10.101:8080 max_fails=2 fail_timeout=30s ;  
    }
  # 很重要的虚拟主机配置
    server {
        listen       80;
        server_name  itoatest.example.com;
        root   /apps/oaapp;
        charset utf-8;
        access_log  logs/host.access.log  main;
        #对 / 所有做负载均衡+反向代理
        location / {
            root   /apps/oaapp;
            index  index.jsp index.html index.htm;
            proxy_pass        http://backend;  
            proxy_redirect off;
            # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
            proxy_set_header  Host  $host;
            proxy_set_header  X-Real-IP  $remote_addr;  
            proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
            
        }
        #静态文件，nginx自己处理，不去backend请求tomcat
        location  ~* /download/ {  
            root /apps/oa/fs;  
            
        }
        location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$   
        {   
            root /apps/oaapp;   
            expires      7d; 
        }
       	location /nginx_status {
            stub_status on;
            access_log off;
            allow 192.168.10.0/24;
            deny all;
        }
        location ~ ^/(WEB-INF)/ {   
            deny all;   
        }
        #error_page  404              /404.html;
        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
  ## 其它虚拟主机，server 指令开始
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;### 常用指令说明&lt;/p&gt;

&lt;h4 id=&quot;main&quot;&gt;main全局配置&lt;/h4&gt;

&lt;p&gt;nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;woker_processes 2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在配置文件的顶级main部分，worker角色的工作进程的个数，master进程是接收并分配请求给worker处理。这个数值简单一点可以设置为cpu的核数&lt;code class=&quot;highlighter-rouge&quot;&gt;grep ^processor /proc/cpuinfo | wc -l&lt;/code&gt;，也是 auto 值，如果开启了ssl和gzip更应该设置成与逻辑CPU数量一样甚至为2倍，可以减少I/O操作。如果nginx服务器还有其它服务，可以考虑适当减少。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;worker_cpu_affinity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也是写在main部分。在高并发情况下，通过设置cpu粘性来降低由于多CPU核切换造成的寄存器等现场重建带来的性能损耗。如worker_cpu_affinity 0001 0010 0100 1000; （四核）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;worker_connections 2048&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;写在events部分。每一个worker进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。nginx作为反向代理服务器，计算公式 最大连接数 = worker_processes * worker_connections/4，所以这里客户端最大连接数是1024，这个可以增到到8192都没关系，看情况而定，但不能超过后面的worker_rlimit_nofile。当nginx作为http服务器时，计算公式里面是除以2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;worker_rlimit_nofile 10240&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;写在main部分。默认是没有设置，可以限制为操作系统最大的限制65535。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;use epoll&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;写在events部分。在Linux操作系统下，nginx默认使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。在操作系统不支持这些高效模型时才使用select。&lt;/p&gt;

&lt;h4 id=&quot;http&quot;&gt;http服务器&lt;/h4&gt;

&lt;p&gt;与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sendfile on&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;keepalive_timeout 65&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;长连接超时时间，单位是秒，这个参数很敏感，涉及浏览器的种类、后端服务器的超时设置、操作系统的设置，可以另外起一片文章了。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s内没上传完成会导致失败。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;send_timeout&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx将会关闭连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;client_max_body_size 10m&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;client_body_buffer_size 128k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缓冲区代理缓冲用户端请求的最大字节数&lt;/p&gt;

&lt;h4 id=&quot;httpproxy&quot;&gt;模块http_proxy&lt;/h4&gt;

&lt;p&gt;这个模块实现的是nginx作为反向代理服务器的功能，包括缓存功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_connect_timeout 60&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nginx跟后端服务器连接超时时间(代理连接超时)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_read_timeout 60&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_buffer_size 4k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置代理服务器（nginx）从后端realserver读取并保存用户头信息的缓冲区大小，默认与proxy_buffers大小相同，其实可以将这个指令值设的小一点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_buffers 4 32k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;proxy_buffers缓冲区，nginx针对单个连接缓存来自后端realserver的响应，网页平均在32k以下的话，这样设置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_busy_buffers_size 64k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;高负荷下缓冲大小（proxy_buffers*2）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_max_temp_file_size&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当 proxy_buffers 放不下后端服务器的响应内容时，会将一部分保存到硬盘的临时文件中，这个值用来设置最大临时文件大小，默认1024M，它与 proxy_cache 没有关系。大于这个值，将从upstream服务器传回。设置为0禁用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_temp_file_write_size 64k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。proxy_temp_path（可以在编译的时候）指定写到哪那个目录。&lt;/p&gt;

&lt;p&gt;proxy_pass，proxy_redirect见 location 部分。&lt;/p&gt;

&lt;h4 id=&quot;httpgzip&quot;&gt;模块http_gzip&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;gzip on&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;开启gzip压缩输出，减少网络传输。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_min_length 1k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是20。建议设置成大于1k的字节数，小于1k可能会越压越大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_buffers 4 16k&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_http_version 1.0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于识别 http 协议的版本，早期的浏览器不支持 Gzip 压缩，用户就会看到乱码，所以为了支持前期版本加上了这个选项，如果你用了 Nginx 的反向代理并期望也启用 Gzip 压缩的话，由于末端通信是 http/1.0，故请设置为 1.0。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_comp_level 6&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_types&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_proxied any&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nginx作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，匹配的前提是后端服务器必须要返回包含”Via”的 header头。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gzip_vary on&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和http头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过gzip压缩的页面，例如，用Squid缓存经过Nginx压缩的数据。。&lt;/p&gt;

&lt;h3 id=&quot;server&quot;&gt;server虚拟主机&lt;/h3&gt;

&lt;p&gt;http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server。每个server通过监听地址或端口来区分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;listen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;监听端口，默认80，小于1024的要以root启动。可以为&lt;code class=&quot;highlighter-rouge&quot;&gt;listen *:80&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;listen 127.0.0.1:80&lt;/code&gt;等形式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;server_name&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;服务器名，如&lt;code class=&quot;highlighter-rouge&quot;&gt;localhost、www.example.com&lt;/code&gt;，可以通过正则匹配。&lt;/p&gt;

&lt;h4 id=&quot;httpstream&quot;&gt;模块http_stream&lt;/h4&gt;

&lt;p&gt;这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡，upstream后接负载均衡器的名字，后端realserver以&lt;code class=&quot;highlighter-rouge&quot;&gt;host:port options&lt;/code&gt;; 方式组织在 {} 中。如果后端被代理的只有一台，也可以直接写在 proxy_pass 。&lt;/p&gt;

&lt;h3 id=&quot;location&quot;&gt;location&lt;/h3&gt;

&lt;p&gt;http服务中，某些特定的URL对应的一系列配置项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;root /var/www/html&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义服务器的默认网站根目录位置。如果locationURL匹配的是子目录或文件，root没什么作用，一般放在server指令里面或/下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index index.jsp index.html index.htm&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义路径下默认访问的文件名，一般跟着root放&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proxy_pass http:/backend&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;请求转向backend定义的服务器列表，即反向代理，对应upstream负载均衡器。也可以&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_pass http://ip:port&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proxy_redirect off;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;其它&lt;/h3&gt;

&lt;h4 id=&quot;allowdeny&quot;&gt;访问控制 allow/deny&lt;/h4&gt;

&lt;p&gt;Nginx 的访问控制模块默认就会安装，而且写法也非常简单，可以分别有多个allow,deny，允许或禁止某个ip或ip段访问，依次满足任何一个规则就停止往下匹配。如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location /nginx-status {
  stub_status on;
  access_log off;
#  auth_basic   &quot;NginxStatus&quot;;
#  auth_basic_user_file   /usr/local/nginx-1.6/htpasswd;
  allow 192.168.10.100;
  allow 172.29.73.0/24;
  deny all;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们也常用 httpd-devel 工具的 htpasswd 来为访问的路径设置登录密码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# htpasswd -c htpasswd admin
New passwd:
Re-type new password:
Adding password for user admin
# htpasswd htpasswd admin    //修改admin密码
# htpasswd htpasswd sean    //多添加一个认证用户
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就生成了默认使用CRYPT加密的密码文件。打开上面nginx-status的两行注释，重启nginx生效。&lt;/p&gt;

&lt;h4 id=&quot;autoindex&quot;&gt;列出目录 autoindex&lt;/h4&gt;

&lt;p&gt;Nginx默认是不允许列出整个目录的。如需此功能，打开nginx.conf文件，在location，server 或 http段中加入&lt;code class=&quot;highlighter-rouge&quot;&gt;autoindex on&lt;/code&gt;;，另外两个参数最好也加上去:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;autoindex_exact_size off&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认为on，显示出文件的确切大小，单位是bytes。改为off后，显示出文件的大概大小，单位是kB或者MB或者GB&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;autoindex_localtime on&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认为off，显示的文件时间为GMT时间。改为on后，显示的文件时间为文件的服务器时间&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location /images {
  root   /var/www/nginx-default/images;
  autoindex on;
  autoindex_exact_size off;
  autoindex_localtime on;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 07 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/07/nginx.conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/07/nginx.conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>Nginx</category>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>如何将DISQUS社会化评论设置为简体中文</title>
        <description>&lt;p&gt;1、首先要打开Disqus的网站，点击右上角的 Sign-in 登录。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F04%2Fpost-bg-disqus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、进入后台。&lt;/p&gt;

&lt;p&gt;登录后回到首页，点击右上角你的头像，选择 Admin，进入管理后台。&lt;/p&gt;

&lt;p&gt;3、选择右上角“Settings”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F04%2F9999.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先给大家看看这些设置都是什么意思：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;APPEARANCE：评论区的样式
COMMENT COUNT LINK： 当评论、回应条数分别为 0、1 时的显示
DEFAULT SORT：默认的回复排序方式
LANGUAGE：评论区的语言
GUEST COMMENTING：是否允许匿名留言
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可将评论数为0、1、多条时的提示语改为中文：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F04%2F2014-04-04_120755.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4、设置语言为简体中文：&lt;/p&gt;

&lt;p&gt;你会发现language没有简体中文，只有chinese(taiwai)。如何选成简体中文？&lt;/p&gt;

&lt;p&gt;a、打开浏览器的开发者工具，快捷键一般为F12&lt;/p&gt;

&lt;p&gt;b、使用元素选取工具定位到语言的选择列表。&lt;/p&gt;

&lt;p&gt;c、将代码部分的zh_TW改为zh。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F04%2F2014-04-04_121348.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;d、选择保存，你会发现，语言选择多出了一项chinese，选择语言为chinese，你的disqus就是简体中文版本了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F04%2F8888.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/04/%E5%A6%82%E4%BD%95%E5%B0%86DISQUS%E7%A4%BE%E4%BC%9A%E5%8C%96%E8%AF%84%E8%AE%BA%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/04/%E5%A6%82%E4%BD%95%E5%B0%86DISQUS%E7%A4%BE%E4%BC%9A%E5%8C%96%E8%AF%84%E8%AE%BA%E8%AE%BE%E7%BD%AE%E4%B8%BA%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87/</guid>
        
        <category>Francis 杂谈</category>
        
        
      </item>
    
      <item>
        <title>如何写出优美的 C 代码</title>
        <description>&lt;p&gt;面向对象的语言更接近人的思维方式，而且在很大程度上降低了代码的复杂性，同时提高了代码的可读性和可维护性，传统的 C 代码同样可以设计出比较易读，易维护，复杂度较低的优美代码，本文将通过一个实际的例子来说明这一点。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;基础知识&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;结构体&lt;/h3&gt;

&lt;p&gt;除了提供基本数据类型外，C 语言还提供给用户自己定制数据类型的能力，那就是结构体，在 C 语言中，你可以用结构体来表示任何实体。结构体正是面向对象语言中的类的概念的雏形，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct{ 
    float x; 
    float y; 
 }Point;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;定义了一个平面坐标系中的一个点，点中有两个域，x 坐标和 y 坐标。&lt;/p&gt;

&lt;p&gt;结构体中的域称为结构体的成员。结构体中的数据类型可以是简单数据类型，也可以是其他的结构体，甚至结构体本身还可以嵌套，比如，一个标准的链表结构可以进行如下定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct node{ 
    void *data;
// 数据指针

    int dataLength;
// 数据长度

    struct node *next;
// 指向下一个节点

 }Node;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，结构体 node 中的 next 指针的类型又是 node 类型。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;函数指针&lt;/h3&gt;

&lt;p&gt;指针是 C 语言的灵魂，是 C 比其他语言更灵活，更强大的地方。所以学习 C 语言必须很好的掌握指针。函数指针，即指向函数在内存映射中的首地址的指针，通过函数指针，可以将函数作为参数传递给另一个函数，并在适当的时候调用，从而实现异步通信等功能。&lt;/p&gt;

&lt;p&gt;比如， UNIX/Linux 系统中的信号注册函数，其原型如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void (*signal(int signo,void (*func)(int))) (int)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用的时候，需要自己在外部定义一个信号处理函数 (signal handler), 然后使用 signal(sigNo, handler) 将处理程序注册在进程上，当信号发生时，进程就可以回调信号处理函数。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;将函数指针作为结构体的成员&lt;/h3&gt;

&lt;p&gt;正如前面提到的，结构体的成员可以是简单的数据结构，也可以是其他的结构体，当然，也可以是指针。当将函数指针作为结构体的成员，并且这些函数只用来操作本结构体中的数据时，就可以形成一个独立的实体，这个实体中既有数据，也有对数据的操作，这样自然就可以引出类(class)的概念。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;面向对象语言的特性&lt;/h2&gt;

&lt;p&gt;一般而言，继承，封装和多态被认为是面向对象语言所必须支持的三种特征，也正是通过这三种特征才可以体现出面向对象在哪些方面优于面向过程。由于语言开发商的宣传或其他的各种原因，使的表面上面向对象的思想要通过语言为载体而得以实现，然而实际上，面向对象是一种软件设计思想，完全是可以与具体实现无关的。&lt;/p&gt;

&lt;p&gt;虽然如此，但是不可否认，这些所谓的纯面向对象的语言，在其代码的可读性以及与人的自然思维的匹配方面，比面向过程的语言要好的多。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;语言层次的面向对象&lt;/h3&gt;

&lt;p&gt;我们一般要描述一个对象，一般需要描述这个对象的一些属性，比如盒子(box) 是一个实体，它有 6 个面，有颜色，重量，是否为空等属性，并且可以放东西进去，可以取东西出来。在面向对象的语言中，通常将这样的对象抽象成一个类 (class):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Box{ 
    clolr color; 
    int weight; 
    boolean empty; 
 
    put(something); 
    something get(); 
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对盒子进行操作时，可以做一下动作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Box.put(cake); 
Box.get();
// 取到某个东西，从盒子中。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而面向过程的语言中，通常是将实体传递给一个贯穿全局的函数来进行的，同样以 Box 为例，对 Box 进行操作时，往往是这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Put(Box, cake);
// 将一个蛋糕放到盒子中

Get(Box);
// 从盒子中取出某个东西来
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而显然，第一种代码形式更符合常理，所以面向对象的语言大都提供这种语言层面的细节的支持，使得代码的可读性，可理解性大大增加。 C 语言，作为一个灵活而简单的语言，我们完全可以通过 C 提供的简单机制，实现这样的比较优美的代码形式。&lt;/p&gt;

&lt;h2 id=&quot;c-&quot;&gt;C 语言的面向对象&lt;/h2&gt;

&lt;p&gt;如前所说，面向对象是一种软件设计的思想，是语言无关的。在本节中，我举一个链表(list)的例子来说明如何在 C 语言中的设计出有面向对象风格的代码。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;定义接口&lt;/h3&gt;

&lt;p&gt;接口是面向对象语言中的一个比较重要的概念，接口只对外部承诺实现该接口的实体可以完成什么样的功能，但是不暴露实现的方式。这样的好处是，实现者可以在不接触接口使用者的代码的情况下，对实现进行调整。&lt;/p&gt;

&lt;p&gt;我们来看看链表的接口定义：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 1. 链表的接口定义&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#ifndef _ILIST_H 
 #define     _ILIST_H 
 
 
// 定义链表中的节点结构

 typedef struct node{ 
    void *data; 
    struct node *next; 
 }Node; 
 
 
// 定义链表结构

 typedef struct list{ 
    struct list *_this; 
    Node *head; 
    int size; 
    void (*insert)(void *node);
// 函数指针

    void (*drop)(void *node); 
    void (*clear)(); 
    int (*getSize)(); 
    void* (*get)(int index); 
    void (*print)(); 
 }List; 
 
 void insert(void *node); 
 void drop(void *node); 
 void clear(); 
 int getSize(); 
 void* get(int index); 
 void print(); 
 
 #endif      /* _ILIST_H */
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;IList 接口中，可以清晰的看到，对于一个 list 实体 ( 也就是对象 ) 来说，可以在其上进行 insert, drop, clear, getSize, get(index) 以及 print 等操作。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;接口的实现&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;清单 2. 构造方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Node *node = NULL; 
List *list = NULL; 
 
void insert(void *node); 
void drop(void *node); 
void clear(); 
int getSize(); 
void print(); 
void* get(int index); 
 
List *ListConstruction(){ 
   list = (List*)malloc(sizeof(List)); 
   node = (Node*)malloc(sizeof(Node)); 
   list-&amp;gt;head = node; 
   list-&amp;gt;insert = insert;
// 将 insert 函数实现注册在 list 实体上

   list-&amp;gt;drop = drop; 
   list-&amp;gt;clear = clear; 
   list-&amp;gt;size = 0; 
   list-&amp;gt;getSize = getSize; 
   list-&amp;gt;get = get; 
   list-&amp;gt;print = print; 
   list-&amp;gt;_this = list;
// 用 _this 指针将 list 本身保存起来

 
   return (List*)list; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是此处的 _this 指针，_this 指针可以保证外部对 list 的操作映射到对 _this 的操作上，从而使得代码得到简化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 3. 插入及删除&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 将一个 node 插入到一个 list 对象上

 void insert(void *node){ 
    Node *current = (Node*)malloc(sizeof(Node)); 
 
    current-&amp;gt;data = node; 
    current-&amp;gt;next = list-&amp;gt;_this-&amp;gt;head-&amp;gt;next; 
    list-&amp;gt;_this-&amp;gt;head-&amp;gt;next = current; 
    (list-&amp;gt;_this-&amp;gt;size)++; 
 } 
 
 
// 删除一个指定的节点 node 

 void drop(void *node){ 
    Node *t = list-&amp;gt;_this-&amp;gt;head; 
    Node *d = NULL; 
    int i = 0; 
    for(i;i &amp;lt; list-&amp;gt;_this-&amp;gt;size;i++){ 
        d = list-&amp;gt;_this-&amp;gt;head-&amp;gt;next; 
        if(d-&amp;gt;data == ((Node*)node)-&amp;gt;data){ 
            list-&amp;gt;_this-&amp;gt;head-&amp;gt;next = d-&amp;gt;next; 
            free(d); 
            (list-&amp;gt;_this-&amp;gt;size)--; 
            break; 
        }else{ 
            list-&amp;gt;_this-&amp;gt;head = list-&amp;gt;_this-&amp;gt;head-&amp;gt;next; 
        } 
    } 
    list-&amp;gt;_this-&amp;gt;head = t; 
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他的实现代码可以参看下载部分，这里限于篇幅就不再意义列举出来。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;测试&lt;/h2&gt;

&lt;h3 id=&quot;section-9&quot;&gt;测试代码&lt;/h3&gt;

&lt;p&gt;好了，前面做的一切工作都是为了保证我们的暴露给使用者的 API 可以尽量的简洁，优美，现在到测试的时候了：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;清单 4. 测试代码&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(int argc, char** argv) { 
    List *list = (List*)ListConstruction();
// 构造一个新的链表

 
 
// 插入一些值做测试

    list-&amp;gt;insert(&quot;Apple&quot;); 
    list-&amp;gt;insert(&quot;Borland&quot;); 
    list-&amp;gt;insert(&quot;Cisco&quot;); 
    list-&amp;gt;insert(&quot;Dell&quot;); 
    list-&amp;gt;insert(&quot;Electrolux&quot;); 
    list-&amp;gt;insert(&quot;FireFox&quot;); 
    list-&amp;gt;insert(&quot;Google&quot;); 
 
    list-&amp;gt;print();
// 打印整个列表

 
    printf(&quot;list size = %d\n&quot;,list-&amp;gt;getSize()); 
 
    Node node; 
    node.data = &quot;Electrolux&quot;; 
    node.next = NULL;  
    list-&amp;gt;drop(&amp;amp;node);
// 删除一个节点

 
    node.data = &quot;Cisco&quot;; 
    node.next = NULL; 
    list-&amp;gt;drop(&amp;amp;node);
// 删除另一个节点

 
    list-&amp;gt;print();
// 再次打印

    printf(&quot;list size = %d\n&quot;,list-&amp;gt;getSize()); 
    list-&amp;gt;clear();
// 清空列表

 
    return 0; 
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;图 1. 运行结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F04%2F0064cTs2jw1ezvcsyh916g309y0740sj.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;结束语&lt;/h2&gt;

&lt;p&gt;C 语言所诞生的UNIX平台提倡这样一种设计哲学：尽量进行简单的设计，让使用者如同搭积木一样的将这些简单的工具连接成强大的，完整的应用。 应该说，C 比较好的继承了这一点，C 语言非常简洁，非常强大，而由于 C 语言诞生的比较早，当时的面向对象的思想还不成熟，所以出现了大量的过程式的 C 应用，从而给人们一种 C 语言是面向过程的语言的错觉，其实 C 只是提供了一些简单，强大而通用的能力，至于你想将其搭成什么样的积木，则全靠你自己了。&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/04/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BC%98%E7%BE%8E%E7%9A%84-C-%E4%BB%A3%E7%A0%81/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/04/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%BC%98%E7%BE%8E%E7%9A%84-C-%E4%BB%A3%E7%A0%81/</guid>
        
        <category>C语言</category>
        
        <category>编程</category>
        
        <category>Francis 杂谈</category>
        
        
      </item>
    
      <item>
        <title>浅谈大型网站动态应用系统架构</title>
        <description>&lt;p&gt;动态应用，是相对于网站静态内容而言，是指以&lt;strong&gt;c/c++、php、Java、perl、.net&lt;/strong&gt;等服务器端语言开发的网络应用软件，比如&lt;strong&gt;论坛、网络相册、交友、BLOG&lt;/strong&gt;等常见应用。动态应用系统通常与数据库系统、缓存系统、分布式存储系统等密不可分。&lt;/p&gt;

&lt;p&gt;大型动态应用系统平台主要是针对于&lt;strong&gt;大流量、高并发&lt;/strong&gt;网站建立的底层系统架构。大型网站的运行需要一个&lt;strong&gt;可靠、安全、可扩展、易维护&lt;/strong&gt;的应用系统平台做为支撑，以保证网站应用的平稳运行。&lt;/p&gt;

&lt;p&gt;大型动态应用系统又可分为几个子系统：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Web前端系统&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;负载均衡系统&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;数据库集群系统&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;缓存系统&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;分布式存储系统&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;分布式服务器管理系统&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;代码分发系统&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;web&quot;&gt;Web前端系统&lt;/h2&gt;

&lt;p&gt;结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F03%2F23c8611eb055424faff943b5d0f0c345.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了达到不同应用的服务器共享、避免单点故障、集中管理、统一配置等目的，不以应用划分服务器，而是将所有服务器做统一使用，每台服务器都可以对多个应用提供服务，当某些应用访问量升高时，通过增加服务器节点达到整个服务器集群的性能提高，同时使他应用也会受益。该Web前端系统基于Apache/Lighttpd/Eginx等的虚拟主机平台，提供PHP程序运行环境。服务器对开发人员是透明的，不需要开发人员介入服务器管理。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;负载均衡系统&lt;/h2&gt;

&lt;p&gt;结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F03%2Ff1ab878d9087306ff476710079f084d9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;负载均衡系统分为硬件和软件两种。硬件负载均衡效率高，但是价格贵，比如F5等。软件负载均衡系统价格较低或者免费，效率较硬件负载均衡系统低，不过对于流量一般或稍大些网站来讲也足够使用，比如lvs, nginx。大多数网站都是硬件、软件负载均衡系统并用。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数据库集群系统&lt;/h2&gt;

&lt;p&gt;结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F03%2F5d85ae32d4ce1d69c6659aa73796d0db.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于Web前端采用了负载均衡集群结构提高了服务的有效性和扩展性，因此数据库必须也是高可靠的，才能保证整个服务体系的高可靠性，如何构建一个高可靠的、可以提供大规模并发处理的数据库体系？&lt;/p&gt;

&lt;p&gt;我们可以采用如上图所示的方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用 MySQL 数据库，考虑到Web应用的数据库读多写少的特点，我们主要对读数据库做了优化，提供专用的读数据库和写数据库，在应用程序中实现读操作和写操作分别访问不同的数据库。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 MySQL Replication 机制实现快速将主库（写库）的数据库复制到从库（读库）。一个主库对应多个从库，主库数据实时同步到从库。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写数据库有多台，每台都可以提供多个应用共同使用，这样可以解决写库的性能瓶颈问题和单点故障问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读数据库有多台，通过负载均衡设备实现负载均衡，从而达到读数据库的高性能、高可靠和高可扩展性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库服务器和应用服务器分离。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从数据库使用BigIP做负载均衡。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;缓存系统&lt;/h2&gt;

&lt;p&gt;结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F03%2Fd257ef6afdc2007bf729dca4a973068b.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;缓存分为文件缓存、内存缓存、数据库缓存。在大型Web应用中使用最多且效率最高的是内存缓存。最常用的内存缓存工具是Memcached。使用正确的缓存系统可以达到实现以下目标：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用缓存系统可以提高访问效率，提高服务器吞吐能力，改善用户体验。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;减轻对数据库及存储集服务器的访问压力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Memcached服务器有多台，避免单点故障，提供高可靠性和可扩展性，提高性能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;分布式存储系统&lt;/h2&gt;

&lt;p&gt;结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F03%2Faf947278e3d6fd5fac17af2e689b4c5c.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Web系统平台中的存储需求有下面两个特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;存储量很大，经常会达到单台服务器无法提供的规模，比如相册、视频等应用。因此需要专业的大规模存储系统。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;负载均衡cluster中的每个节点都有可能访问任何一个数据对象，每个节点对数据的处理也能被其他节点共享，因此这些节点要操作的数据从逻辑上看只能是一个整体，不是各自独立的数据资源。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此&lt;strong&gt;高性能的分布式存储系统对于大型网站应用来说是非常重要的一环&lt;/strong&gt;。（这个地方需要加入对某个分布式存储系统的简单介绍。）&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;分布式服务器管理系统&lt;/h2&gt;

&lt;p&gt;结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F03%2F1178fd6019a70d78c813bd0d66e6304a.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随着网站访问流量的不断增加，大多的网络服务都是以负载均衡集群的方式对外提供服务，随之集群规模的扩大，原来基于单机的服务器管理模式已经不能够满足我们的需求，新的需求必须能够集中式的、分组的、批量的、自动化的对服务器进行管理，能够批量化的执行计划任务。&lt;/p&gt;

&lt;p&gt;在分布式服务器管理系统软件中有一些比较优秀的软件，其中比较理想的一个是Cfengine。它可以对服务器进行分组，不同的分组可以分别定制系统配置文件、计划任务等配置。它是基于C/S 结构的，所有的服务器配置和管理脚本程序都保存在Cfengine Server上，而被管理的服务器运行着 Cfengine Client 程序，Cfengine Client通过SSL加密的连接定期的向服务器端发送请求以获取最新的配置文件和管理命令、脚本程序、补丁安装等任务。&lt;/p&gt;

&lt;p&gt;有了Cfengine这种集中式的服务器管理工具，我们就可以高效的实现大规模的服务器集群管理，被管理服务器和 Cfengine Server 可以分布在任何位置，只要网络可以连通就能实现快速自动化的管理。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;代码发布系统&lt;/h2&gt;

&lt;p&gt;结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xl0td.com1.z0.glb.clouddn.com/2016%2F03%2F03%2Fd3459694dbf3e7bde14319457ea41178.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随着网站访问流量的不断增加，大多的网络服务都是以负载均衡集群的方式对外提供服务，随之集群规模的扩大，为了满足集群环境下程序代码的批量分发和更新，我们还需要一个程序代码发布系统。&lt;/p&gt;

&lt;p&gt;这个发布系统可以帮我们实现下面的目标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;生产环境的服务器以虚拟主机方式提供服务，不需要开发人员介入维护和直接操作，提供发布系统可以实现不需要登陆服务器就能把程序分发到目标服务器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们要实现内部开发、内部测试、生产环境测试、生产环境发布的4个开发阶段的管理，发布系统可以介入各个阶段的代码发布。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们需要实现源代码管理和版本控制，SVN可以实现该需求。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里面可以使用常用的工具Rsync，通过开发相应的脚本工具实现服务器集群间代码同步分发。&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://www.francissoung.com/2016/03/03/%E6%B5%85%E8%B0%88%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E5%8A%A8%E6%80%81%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</link>
        <guid isPermaLink="true">http://www.francissoung.com/2016/03/03/%E6%B5%85%E8%B0%88%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E5%8A%A8%E6%80%81%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</guid>
        
        <category>架构</category>
        
        <category>Francis 杂谈</category>
        
        
      </item>
    
  </channel>
</rss>
